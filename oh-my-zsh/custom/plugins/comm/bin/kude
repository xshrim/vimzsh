#!/bin/bash

kc=""
image=xo
port=""
timeout=60
user=root
cfile=""
#passwd=root
idx=0
since=""
amount=""
kwd=""
list=0
kind=""
context=""
selector=""
args=""
chroot=""
neat=0
localrun=0
savepath=""
vol=""
dryrun=""
output=""

mandatory=()

function usage() {
  echo '
**USAGE**:
  kude <command> [<options>] [<object>]

**COMMANDS**:
  hp,help                  打印命令帮助
  print                    打印脚本文件内容
  git                      git运行git命令
  g,go                     运行go命令
  lg,lgo                   Linux环境下禁用CGO的go命令
  h,helm                   运行helm命令
  d,docker                 运行docker命令
  dc,dkc,docker-compose    运行docker-compose命令
  dcu,dcd                  启动或停止docker-compose容器
  k,kube,kubectl           运行kubectl命令
  kd                       运行kind命令
  kk                       运行kubectl kustomize命令
  km,kustomize             运行kustomize命令
  ec,edc,etcdctl           运行etcdctl命令
  td,tdp,tcpdump           运行tcpdump抓包命令
  ts,tsk,tshark            运行tshark抓包命令(wireshark)
  it,iptable,iptables      运行iptables命令
  nm,nmap                  运行nmap命令
  pt,pst,pstree            查看进程树
  ps,portstat,portstatus   运行端口检测命令
  pc,portctl,portcontrol   运行端口开放关闭命令
  py,py3,python            执行python3命令
  px                       在http代理环境执行命令
  pxs,goproxy              运行goproxy代理服务器
  ans                      提取ansible的json输出
  bat                      批量执行远程命令
  ldf                      统计系统分区空间占用
  lfd                      统计系统磁盘大小
  ldu                      统计目录磁盘占用
  lkl                      查看内核信息
  ljc                      查看系统日志
  ldd                      查看动态链接库文件依赖
  so                       查看动态链接库文件信息
  st                       查看系统各项stat信息
  n,net                    运行网络相关命令
  ym,yum                   运行yum相关命令
  jy,j2y                   json数据转换为yaml格式
  yj,y2j                   yaml数据转换为json格式
  ac,autocomplete          开启命令自动补全
  cu,au,createuser,adduser 创建用户
  opt,optimize             对操作系统进行k8s环境优化
  ct,ssl,cred              加密凭证操作
  cv,convert               格式转换
  sp,sample                输出模板示例
  id,uuid,guid             生成随机id
  tm,time                  时间相关操作
  c,cmd                    运行linux命令
  ch,chp                   在线命令帮助
  scp                      分发本机文件
  gs                       git一键提交并上传
  gl                       git一键拉取
  gg                       git查看提交日志
  pq,promq                 prometheus查询api
  ghp,gweb,ghelp           查看go命令帮助
  dhp,dweb,dhelp           查看docker命令帮助
  khp,kweb,khelp           查看kubectl命令帮助
  dr,drun                  运行容器
  drt,dtmp                 运行临时容器
  dat,dattach              attach到目标容器
  dx,ddbg                  运行共享目标容器命名空间的镜像(调试)
  dsa,dstart               启动docker容器
  dsp,dstop                停止docker容器
  de,dexe,dexec            在容器中执行命令
  die,diexe,diexec         在容器中交互式执行命令
  dcp                      在本地和容器之间复制文件
  dtp,dtop                 查看容器中运行的进程
  dlg,dlog                 查看容器日志
  dlf,dlogf                实时查看容器日志
  dst,dstat,dstats         监控docker容器
  dreg,dregistry           启动私有镜像仓库
  dq,dsearch               搜索镜像仓库
  dck,dcheck               检查镜像仓库是否存在指定镜像列表
  db,dbd                   构建docker镜像
  dt,dtg,dtag              为镜像打标签
  dps,dlist                查看容器列表
  dpt,dpst                 查看容器进程树
  dm,dim,dimg              查看镜像列表
  di,din,dinsp             查看容器配置信息
  dmi,dmin,dminsp          查看镜像配置信息
  dn,dnet                  查看docker网络列表
  dv,dvol                  查看docker卷列表
  dd,drm                   删除容器
  do,drmi                  删除镜像
  drmn                     删除none镜像
  dh,dhi,dhist             查看镜像构建历史
  ds,dput,dpush            推送镜像
  dl,dget,dpull            拉取镜像
  dpa,daddr                查看容器网络信息
  dpe,denv                 查看容器环境变量
  dpl,dlp                  查看容器日志路径
  dpc,dcmd                 查看容器运行命令
  dpp,dport                查看容器端口映射
  dpm,dmnt                 查看容器卷挂载
  dcc                      删除所有已退出的容器
  dic                      删除所有未使用的镜像
  dvc                      删除所有未使用的容器卷
  dnc                      删除所有未使用的网络
  cf,cfind                 查找当前目录下包含指定关键字的文件
  df,dfind                 查找容器配置中包含指定关键字的容器
  kf,kfind                 查找资源中包含指定关键字的资源
  cfg,config               查看kubeconfig配置
  kg,gencfg                生成kubeconfig配置
  exp,explain              查看k8s资源描述
  expr,explainr            查看k8s资源及嵌套资源描述
  dry,dryrun               模拟执行kubectl命令
  ee,etcd,etcdexe          执行etcdctl命令操作etcd数据库
  ap,apl,apply             执行kubectl apply命令
  cr,crt,create            执行kubectl create命令
  r,run                    执行kubectl run命令
  b,rbac                   查看rbac结构图
  a,all                    查看指定命名空间下所有资源
  np,nodepod               列出运行在指定节点上的所有pod
  ni,nodeimg               列出指定节点上所有的镜像
  re,res                   列出k8s集群支持的所有资源
  ver,version              列出k8s集群的api版本
  ro,rollout               执行kubectl rollout命令
  au,auth                  执行kubectl auth命令
  pr,proxy                 开启kube apiserver本地代理
  tk,token                 获取serviceaccount的token
  cs,crtsec,createsecret   创建secret资源
  lb,label                 为资源增加或删除标签
  lba,labela               为所有指定资源增加或删除标签
  lbo,labelo               为资源增加或覆盖标签
  lbao,labelao             为所有指定资源增加或覆盖标签
  li,lsimg                 列出k8s中所有容器使用的镜像
  lli,llimg                按行列出k8s中所有容器使用的镜像
  l,log                    查看pod内容器日志
  lf,logf                  实时查看容器日志
  lb,label                 执行kubectl label命令
  i,insp,inspect           查看容器配置信息
  f,gt,get                 查看k8s资源信息
  s,desc,describe          查看k8s资源详细信息
  wt,watch                 监视指定k8s资源状态
  w,wide                   查看k8s资源更多信息
  wl,wlabel                查看k8s资源包括label在内的更多信息
  y,yn,yaml                以yaml格式查看k8s资源信息
  j,jn,json                以json格式查看k8s资源信息
  tp,top                   查看node或pod资源占用
  ed,edit                  编辑指定k8s资源
  p,patch                  为k8s资源打补丁
  rm,del,delete            删除指定k8s资源
  rmf,delf,deletef         强制删除指定k8s资源
  e,exe,exec               在pod中执行命令
  ie,iexe,iexec            在pod中交互式执行命令
  at,attach                加入pod的命名空间
  cp,copy                  在本地和pod之间复制文件
  pf,forward,port-forward  将本地端口映射到pod端口实现端口转发
  x,dbg,debug              运行调试容器对pod进行调试

**OPTIONS**:
  -a [10m] log显示指定时间之后的日志
  -b [100] log显示条数
  -c [context] kubernetes连接上下文(可选)
  -d [savedir] rbac结构图保存目录(可选)
  -f [./kube/config] kubeonfig文件路径(可选)
  -h [host] 指定目标主机ip
  -i [0] 匹配pod内容器index(可选)
  -k [kind] k8s资源类型
  -l [selector] k8s资源标签选择器
  -m [xo] 自定义调试工具容器(可选)
  -n [default] 查询的k8s命名空间(可选)
  -o [yaml] 输出格式
  -p [22] 目标主机ssh端口(可选)
  -s [admin123] 目标主机ssh密码(可选)
  -t [60] 目标主机ssh连接超时时间(可选)
  -u [root] 目标主机ssh账号(可选)
  -w [kwd] 过滤关键字
  -g 列出满足条件的所有资源
  -j 配合cmd本机执行命令
  -q yaml或json精简输出
  -r 调试容器中是否需要chroot到目标容器的文件系统
  -v 调试容器中是否需要挂载目标主机的docker.sock文件
  -y 模拟运行命令
  -h 使用说明
'
  if [ "$1" != "simple" ]; then
    echo '
**REFERENCES**:
# Linux: https://community.linuxmint.com/tutorial/view/244 https://man.linuxde.net/
# Docker: https://docs.docker.com/engine/reference/commandline/cli/
# Kubectl: https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/
# Etcd: https://etcd.io/docs/v3.4.0/op-guide/configuration/ https://etcd.io/docs/v3.4.0/dev-guide/interacting_v3/
# Helm: https://helm.sh/docs/helm/helm/

**EXAMPLES**:
# 直接执行docker或kubectl命令
kude d ps -a     #相当于docker ps -a
kude k get pod   #相当于kubectl get pod

# 查看docker或kubectl命令帮助
kude dhp run
kude khp get

# 进行docker镜像推送并删除临时tag
kude ds xshrim/xo foo.bar.com/xshrim

# 查看docker容器运行的命令
kude dpc nginx

# 删除包含指定关键字的容器
kude drm alp

# 查看镜像构建历史
kude dh xshrim/xo

# 远程到目标主机执行命令
kude cmd "ls /etc" 127.0.0.1 10.20.0.12-18
kude cmd -p 22 -s admin "ls /etc" 127.0.0.1

# 执行本机命令
kude cmd "scp test root@10.0.0.10:/root/test"

# 批量配置免密登录
kude -u root -s abcde@123 -j cmd 'ssh-copy-id -p 22' 10.0.0.10-20

# 将本地文件分发到远程主机
kude scp "./foo:/root/bar" 10.20.0.12-18

# 自动创建用户并配置密码
kude au foo bar

# 查看主机网卡列表和详细信息
kude net ipa
kude net ipp UP
kude net ips 192.168

# 查看端口状态
kude ps 10.0.0.10 80

# 开启http(s)代理服务器
kude pxs http

# 在http(s)代理环境执行命令
kude px 8888 curl www.google.com

# 查看prometheus指标信息
kude pq metadata 127.0.0.1:9090 process_open_fds
kude pq md 127.0.0.1:9090 open instance=node-exporter

# 获取Kubernetes RBAC结构图
kude b u demouser
kude rbac -n kube-system rolebinding

# 查看kubeconfig配置
kude cfg

# 获取k8s集群容器使用的镜像
kude li -n default
kude lli

# 获取指定serviceaccount的token
kude tk
kude tk -n default

# 执行kubectl apply命令
kude ap pod.yaml

# 查找包含指定字符串的资源
kude kf -k sa token-ec9kd

# 开启kube-apiserver本地代理
kude pr 8443
kude pr 127.0.0.1:8443

# 查看pod容器日志
kude l nginx
kude lf nginx
kude lf -a 10 nginx
kude log -i 1 nginx
kude lf -l app=web

# 查看k8s资源详细信息
kude s nginx
kude desc -k deploy nginx

# 查找包含指定关键字的资源
kude -c acp-global -k sa -n default kf token-pfmd8

# 以yaml格式查看k8s资源信息
kude y nginx
kude yaml -k rs nginx

# 监视k8s资源状态
kude watch -k deploy nginx

# 为k8s资源打补丁
kude p -k deploy nginx "{\"spec\":{\"replicas\":2}}"

# 进入pod执行命令
kude e nginx -n default ls
kude ie nginx

# 在本地和pod之间复制文件
kude cp nginx :/foo ./foo
kude cp nginx -n default bar :/bar

# 将本地端口映射到pod端口实现端口转发
kude pf nginx 8000:80
kude -c minikube pf nginx -n default 8000:80

# 运行调试容器对pod内的指定容器进行调试
kude x nginx
kude debug -n xshrim -u root -p 22 -s admin123 -m netshoot nginx
'
  fi
}

function nethelp() {
  echo '
**USAGE**:
  kude n <commands> [<arguments>]

**COMMANDS**:
  h,hp,help                打印pq命令帮助
  arp                      查看arp列表
  pi                       ping主机或域名
  pp                       批量ping获取主机存活状态
  br                       执行网桥控制命令
  brs                      查看网桥列表
  brl                      查看bridge link
  brv                      查看bridge vlan
  brf                      查看bridge fdb
  brm                      查看bridge mdb
  ip                       执行ip命令
  ipf                      查看bridge fdb
  ipn                      查看主机arp表
  ipr                      查看主机路由信息
  ipa                      查看主机网卡列表
  ipp                      查看主机物理网卡列表
  ips                      查看指定网卡详细信息
  tr                       执行mtr/traceroute命令
  ss                       查看主机网络统计信息(netstat,ss)
  nl                       域名解析
  nm                       执行nmap命令
  td                       执行tcpdump命令
  ts                       执行tshark命令
  it                       执行iptables命令
  ps                       查看端口状态
  pc                       设置端口开放关闭
  pxs                      运行goproxy代理服务器
'
}

function idhelp() {
  echo '
**USAGE**:
  kude id/uuid/guid [<commands>]

**COMMANDS**:
  h,hp,help                打印id/uuid/guid命令帮助
  uuid                     随机打印小写字母和数字组合的32字符uuid
  uuid -                   随机打印带分隔符的小写字母和数字组合的32字符uuid
  guid                     随机打印字母和数字组合的32字符guid
  guid -                   随机打印带分隔符的字母和数字组合的32字符guid
  id <num>                 随机打印num个字母和数字组合的字符
  id n <num>               随机打印num个数字
  id l <num>               随机打印num个小写字母
  id u <num>               随机打印num个大写字母
  id c <num>               随机打印num个字母
  id nl <num>              随机打印num个小写字母和数字组合的字符
  id nu <num>              随机打印num个大写字母和数字组合的字符
  id nc <num>              随机打印num个字母和数字组合的字符
  id a <num>               随机打印num个字母和数字组合的字符
  '
}

function kindhelp() {
  echo '
**USAGE**:
  kude kd [<commands>]

**COMMANDS**:
  h,hp                    打印命令帮助
  help                    打印kind命令帮助
  cl,ls,list              打印集群列表
  ssl,pki                 复制集群相关凭证到本地
  ac,completion           kind命令自动补全
  l,log                   查看kind节点中的容器内的日志
  lf,logf                 实时查看kind节点中的容器内的日志
  ld,load                 向kind节点中加载镜像
  d,dc                    在kind节点中执行docker命令
  e,exe                   在kind节点中的容器内执行命令
  i,ie,iexe               交互式进入kind节点中的容器内
  rm,del,delete           删除集群
  '
}

function timehelp() {
  echo '
**USAGE**:
  kude tm [<commands>]

**COMMANDS**:
  h,hp,help                打印time命令帮助
  l,local                  打印当地时间
  e,en                     以英文打印当地时间
  u,utc                    打印utc时间
  d,date                   仅显示日期
  t,time                   仅显示时间
  w,week                   仅显示星期
  std,standard             以标准格式打印当前时间
  fmt,format               以格式化格式打印当前时间
  ts,timestamp             打印当前时间戳
  tsn,tsns,timestampns     打印当前纳秒时间戳
  tsm,tsms,timestampms     打印当前毫秒时间戳
  cv,convert               进行字符串时间和时间戳之间的转换

**FORMAT**:
%H 小时，24小时制（00~23）
%I 小时，12小时制（01~12）
%k 小时，24小时制（0~23）
%l 小时，12小时制（1~12）
%M 分钟（00~59）
%p 显示出AM或PM
%r 显示时间，12小时制（hh:mm:ss %p）
%s 从1970年1月1日00:00:00到目前经历的秒数
%S 显示秒（00~59）
%T 显示时间，24小时制（hh:mm:ss）
%X 显示时间的格式（%H:%M:%S）
%Z 显示时区，日期域（CST）
%a 星期的简称（Sun~Sat）
%A 星期的全称（Sunday~Saturday）
%h,%b 月的简称（Jan~Dec）
%B 月的全称（January~December）
%c 日期和时间（Tue Nov 20 14:12:58 2012）
%d 一个月的第几天（01~31）
%x,%D 日期（mm/dd/yy）
%j 一年的第几天（001~366）
%m 月份（01~12）
%w 一个星期的第几天（0代表星期天）
%W 一年的第几个星期（00~53，星期一为第一天）
%y 年的最后两个数字（1999则是99）
  '
}

function promqhelp() {
  echo '
**USAGE**:
  kude pq <commands> [<arguments>]

**COMMANDS**:
  h,hp,help                打印pq命令帮助
  i,m,md,info,metadata     打印指标元数据信息
  s,inst,series,instance   打印series信息
  l,v,lv,lb,label,value    打印label及其value数据
  t,tg,target              打印target数据
  r,rl,rule                打印rule数据
  a,al,alert               打印alert数据
  am,alertmanager          打印alertmanager配置
  v,status                 打印prometheus状态信息
  q,query                  使用promql进行查询
  qr,rq,query_range        使用promql进行范围查询
  '
}

function cshelp() {
  echo '
**USAGE**:
  kude cs <commands> [<arguments>]

**COMMANDS**:
  h,hp,help                打印createsecret命令帮助
  g,gl,generic-literal     通过literal生成通用secret资源
  gf,generic-file          通过file生成通用secret资源
  ge,generic-env           通过env生成通用secret资源
  d,dr,docker-registry     生成docker registry secret资源
  t,tl,tls                 生成tls secret资源

**EXAMPLES**:
# 生成generic secret
kude cs gl demo foo=bar zoo=daa
kude cs gf demo ca=ca.pem pk=key.pem ct=cert.pem file.txt
kude cs ge demo bar.env

# dryrun生成docker registry secret
kude cs d demo -y hub.cpaas.io admin Password

# dryrun生成tls secret并输出为yaml
kude cs t demo -y -o yaml --cert=tls.cert --key=tls.key
  '
}

function yumhelp() {
  echo '
**USAGE**:
  kude yum <commands> [<arguments>]

**COMMANDS**:
  h,hp                     打印yum命令帮助
  help                     打印原yum命令帮助
  cr,repo                  构建本地源
  c,cfg                    配置本地源
  d,dl                     下载rpm软件包
  q,rq                     使用repoquery查询
  s,sq                     搜索软件包
  l.list                   列出软件包
  i,inst                   安装软件包
  r,del                    删除软件包
  '
}

function helmhelp() {
  echo '
**USAGE**:
  kude helm <commands> [<arguments>]

**COMMANDS**:
  h,hp                     打印helm命令帮助
  help                     打印原helm命令帮助
  t,temp,template          执行helm template命令
  s,search                 执行helm search命令
  sh,shub,searchhub        执行helm search hub命令
  p,pkg,package            执行helm package命令
  i,inst,install           执行helm install命令
  u,upd,upgrade            执行helm upgrade命令
  d,del,delete             执行helm delete命令
  c,crt,create             执行helm create命令
  f,pull,fetch             执行helm fetch命令
  l,lst,list               执行helm list命令
  v,vfy,verify             执行helm verify命令
  r,rp,repo                执行helm repo命令
  a,sts,status             执行helm status命令
  '
}

function converthelp() {
  echo '
**USAGE**:
  kude cv <commands> [<arguments>]

**COMMANDS**:
  h,hp,help                打印convert命令帮助
  id,identify              获取图片格式特性
  doc,document             将指定文档转换为指定文档格式
  img,image                将指定图片或视频转换为指定图片格式
  vdo,video                将指定音视频转换为指定音视频格式
  txt                      将指定文档转换为txt格式
  htm,html                 将指定文档转换为html格式
  docx,word                将指定文档转换为docx格式
  md,markdown              将指定文档转换为markdown格式
  epub                     将指定文档转换为epub格式
  pdf                      将指定文档转换为pdf格式
  rst                      将指定文档转换为rst格式
  odt                      将指定文档转换为odt格式
  rtf                      将指定文档转换为rtf格式
  json                     将指定文档转换为json格式
  ico                      将指定图片转换为ico格式
  png                      将指定图片转换为png格式
  jpg                      将指定图片转换为jpg格式
  bmp                      将指定图片转换为bmp格式
  gif                      将指定图片转换为gif格式
  tif                      将指定图片转换为tif格式
  tiff                     将指定图片转换为tiff格式
  webp                     将指定图片转换为webp格式
  mp4                      将指定视频转换为mp4格式
  avi                      将指定视频转换为avi格式
  wmv                      将指定视频转换为wmv格式
  3gp                      将指定视频转换为3gp格式
  rm                       将指定视频转换为rm格式
  rmvb                     将指定视频转换为rmvb格式
  mkv                      将指定视频转换为mkv格式
  mov                      将指定视频转换为mov格式
  rs,resize                改变指定图片或视频尺寸
  ql,sc,scale,quality      图片或视频质量压缩
  cc,concat                音视频拼接
  cut                      音视频或图片或pdf裁剪
  an,audiono               去除视频中的音频
  vn,mp3,videono           去除视频中的视频(视频转音频)
  rt,rotate                旋转图片
  fi,flip                  上下翻转图片
  fo,flop                  左右翻转图片
  br,blur                  高斯模糊图片
  bw,gray                  将图片变为黑白
  ng,negate                将图片反色
  ns,noise                 图片加噪音
  pt,paint                 图片油画效果
  cc,charcoal              图片炭笔效果
  sp,spread                图片散射毛玻璃效果
  sw,swirl                 图片漩涡效果
  ri,raise                 图片凸起效果
  bd,border                图片加边框
  wm,watermark             图片加水印
  '
}

function sslhelp() {
  echo '
**USAGE**:
  kude ssl <commands> [<arguments>]

**COMMANDS**:
  h,hp,help                打印ssl命令帮助
  gen,generate             生成整套openssl-x509凭证
  out,show                 打印openssl-x509证书或密钥信息
  mat,match                检查证书与密钥是否匹配
  ver,verify               检查证书与签发者证书是否匹配
  get,fetch                获取url的证书
  sver,sverify             检查url证书与域名是否匹配
  '
}

function gensslhelp() {
  echo ' ================================================================ '
  echo ' --ssl-domain: 生成ssl证书需要的主域名，如不指定则默认为localhost，如果是ip访问服务，则可忽略；'
  echo ' --ssl-trusted-ip: 一般ssl证书只信任域名的访问请求，有时候需要使用ip去访问server，那么需要给ssl证书添加扩展IP，多个IP用逗号隔开；'
  echo ' --ssl-trusted-domain: 如果想多个域名访问，则添加扩展域名（SSL_TRUSTED_DOMAIN）,多个扩展域名用逗号隔开；'
  echo ' --ssl-size: ssl加密位数，默认2048；'
  echo ' --ssl-date: ssl有效期，默认10年；'
  echo ' --ca-date: ca有效期，默认10年；'
  echo ' --ssl-cn: 国家代码(2个字母的代号),默认CN;'
  echo ' --ca-reuse: 是否复用指定CA私钥和证书;'
  echo ' --ca-key: 指定复用的CA私钥路径;'
  echo ' --ca-cert: 指定复用的CA证书路径;'
  echo ' 使用示例:'
  echo ' kude ssl gen --ssl-domain=www.test.com --ssl-trusted-domain=*.test1.com,www.test2.com \ '
  echo ' --ssl-trusted-ip=1.1.1.1,2.2.2.2,3.3.3.3 --ssl-size=2048 --ca-date=18250 --ssl-date=3650 --ssl-cn=CN'
  echo ' or'
  echo ' kude ssl gen --ssl-domain=www.test.com --ssl-trusted-domain=*.test1.com,www.test2.com \ '
  echo ' --ssl-trusted-ip=1.1.1.1,2.2.2.2 --ssl-size=2048 --ssl-date=3650 --ssl-cn=CN --ca-reuse=true ca-key=cakey.pem ca-cert=cacerts.pem'
  echo ' ================================================================'
}

function tcpdumphelp() {
  echo '
[tcpdump选项]:
-A: 以ASCII文本显示抓包内容
-D: 列出所有网络接口
-F: 从文件中读取抓包的表达式
-P: 指定要抓取的包是流入还是流出的包
-X: 以16进制显示数据包承载的数据内容
-l: 使标准输出变为缓冲行形式
-c: 抓包次数
-n: 禁用域名解析
-s: 设置每个数据包的大小
-i: 指定监听的网络接口
-r: 从指定的文件中读取包
-w: 输出信息保存到指定文件
-a: 将网络地址和广播地址转变成名字
-d: 将匹配信息包的代码以人们能够理解的汇编格式给出
-e: 在输出行打印出数据链路层的头部信息
-f: 将外部的 Internet 地址以数字的形式打印出来
-t: 在输出的每一行不打印时间戳
-q: 快速打印简短输出
-v: 输出稍微详细的报文信息
-nn: 直接以IP及Port显示而非主机名与服务名称
-vv: 输出更详细报文信息
-vvv: 尝试解析应用层协议输出更详细报文信息

[tcpdump关键字]:
方向关键字: src, dst
类型关键字: host, net, port, portrange
协议关键字: ip, ip6, arp, tcp, udp, icmp, ether
协议内容过滤: proto[x:y]: 过滤协议从x字节开始的y字节数
逻辑运算符: ! not, && and, || or
tcp标记: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece, tcp-cwr
计算字符串二进制: list(map(hex, [ord(x) for x in "GET "]))

[tcpdump示例]:
# 从所有网卡抓取数据包
tcpdump -i any

# 抓取整个网段的数据包
tcpdump net 192.168.1.0/24

# 抓取包含172.16.1.122的数据包  
tcpdump -i eth0 -vnn host 172.16.1.122  

# 抓取包含172.16.1.0/24网段的数据包  
tcpdump -i eth0 -vnn net 172.16.1.0/24  

# 抓取包含端口22-50的数据包  
tcpdump -i eth0 -vnn portrange 22-50

# 抓取udp协议的数据包  
tcpdump -i eth0 -vnn  udp

# 抓取icmp协议的数据包  
tcpdump -i eth0 -vnn icmp  

# 抓取arp协议的数据包  
tcpdump -i eth0 -vnn arp  

# 抓取ip协议的数据包  
tcpdump -i eth0 -vnn ip

# 抓取目的ip是10网段的数据包
tcpdump -i any -nn "ip[16] == 10"

# 抓取目的ip范围是 192.168.1.10 ~ 192.168.1.100网段的数据包
tcpdump -i any -nn "ip[16] == 192 and ip[17] == 168 and ip[18] == 1 and ip[19] > 9 and ip[19] < 101"

# 抓取源ip是172.16.1.122数据包 
tcpdump -i eth0 -vnn src host 172.16.1.122  

# 抓取目的ip是172.16.1.122数据包  
tcpdump -i eth0 -vnn dst host 172.16.1.122  

# 抓取源端口是22的数据包  
tcpdump -i eth0 -vnn src port 22  

# 抓取源ip是172.16.1.253且目的ip是22的数据包  
tcpdump -i eth0 -vnn src host 172.16.1.253 and dst port 22  

# 抓取源ip是172.16.1.122或者包含端口是22的数据包  
tcpdump -i eth0 -vnn src host 172.16.1.122 or port 22  

# 抓取源ip是172.16.1.122且端口不是22的数据包  
tcpdump -i eth0 -vnn src host 172.16.1.122 and not port 22  

# 抓取源ip是172.16.1.59且目的端口是22，或源ip是172.16.1.68且目的端口是80的数据包
tcpdump -i  eth0 -vnn "src host 172.16.1.59 and dst port 22" or  " src host 172.16.1.68 and dst port 80 "

# 把抓取的数据包记录存到/tmp/fill.cap文件中，当抓取100个数据包后就退出程序 
tcpdump –i eth0 -vnn -w  /tmp/fill.cap -c 100  

# 从/tmp/fill.cap记录中读取tcp协议的数据包  
tcpdump –i eth0 -vnn -r  /tmp/fill.cap tcp  

# 从/tmp/fill记录中读取包含172.16.1.58的数据包  
tcpdump –i eth0 -vnn -r  /tmp/fill.cap host  172.16.1.58

# 抓取所有经过eth0的目的地址是10.10.1.254或10.10.1.200端口是80的TCP数据包
# tcpdump -i eth0 "((tcp) and (port 80) and ((dst host 10.10.1.254) or (dst host 10.10.1.200)))"

# 抓取目标域名是foo.bar的数据包
tcpdump -i eth0 -vn dst host foo.bar

# 抓取域名为foo.bar且非80和25端口的数据包
tcpdump -i eth0 host foo.bar and not port 80 and not port 25

# 抓取http get数据包
tcpdump -i eth0 "tcp[(tcp[12]>>2):4] = 0x47455420"
tcpdump -i eth0 "tcp[20:2]=0x4745 or tcp[20:2]=0x4854"

# 抓取http get数据包
tcpdump -s 0 -A "tcp dst port 80 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420"

# 抓取https post数据包
tcpdump -s 0 -A "tcp dst port 443 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354)"

# 抓取http和https的get和post数据包
tcpdump -i any -s 0 -A "tcp dst port 80 or tcp dst port 443 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420 or tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504F5354" and host 192.168.10.1

# 抓取到指定端口http get数据包并输出最详细信息
tcpdump -i any -s 0 -nnvvvXS -A "tcp dst port 8000 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420"

# 抓取ssh返回数据包
tcpdump -i eth0 "tcp[(tcp[12]>>2):4] = 0x5353482D"

# 抓取http响应数据包
tcpdump -i eth0 "tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x48545450 && tcp[((tcp[12:1] & 0xf0) >> 2) + 4:2] = 0x2f31 && tcp[((tcp[12:1] & 0xf0) >> 2) + 6:1] = 0x2e"

# 抓取dns请求数据包
tcpdump -i eth0 udp dst port 53

# 抓取tcp协议数据包
tcpdump -i eth0 tcp

# 抓取大于600字节的数据包
tcpdump -i eth0 "ip[2:2] > 600"

# 抓取源端口大于1024的数据包
tcpdump -i eth0 "tcp[0:2] > 1024"

# 抓取tcp syn/ack数据包
tcpdump -i eth0 "tcp[tcpflags] & (tcp-syn|tcp-ack) != 0"

# 获取http请求的URL
tcpdump -i any -s 0 -v -n -l | egrep -i "POST / | GET / | Host:"

# 获取http请求密码
tcpdump -i any -s 0 -A -n -l | egrep -i "POST /|pwd=|passwd=|password=|Host:"

# 获取http请求 cookie
tcpdump -i any -nn -A -s0 -l | egrep -i "Set-Cookie|Host:|Cookie:"

# 获取http请求user agent
tcpdump -vvAls0 | grep "User-Agent:"

# 计算抓取10000各syn数据包所使用的时间从而估算访问量
time tcpdump -nn -i eth0 "tcp[tcpflags] = tcp-syn" -c 10000 > /dev/null

# 保存10000个数据包过滤条件为443端口并解析来源IP
tcpdump -i any -nn -c 10000 port 443 > tcpdump.log
cat tcpdump.log | awk "{print $3}" | awk -F "." "{print $1"."$2"."$3"."$4}" | sort | uniq -c | sort -rn

# 后台滚动抓包
nohup tcpdump -i eth0 port 22 -s0 -G 3600 -Z root -w ssh22_%Y_%m%d_%H%M_%S.pcap &
'
}

function tsharkhelp() {
  echo '
[tshark选项]:
-i: 设置抓包的网络接口，不设置则默认为第一个非自环接口
-D: 列出当前存在的网络接口。在不了解OS所控制的网络设备时，一般先用“tshark -D”查看网络接口的编号以供-i参数使用
-f: 设定抓包过滤表达式（capture filter expression）。抓包过滤表达式的写法雷同于tcpdump，可参考tcpdump man page的有关部分
-s: 设置每个抓包的大小，默认为65535，多于这个大小的数据将不会被程序记入内存、写入文件。（这个参数相当于tcpdump的-s，tcpdump默认抓包的大小仅为68）
-p: 设置网络接口以非混合模式工作，即只关心和本机有关的流量
-B: 设置内核缓冲区大小，仅对windows有效
-y: 设置抓包的数据链路层协议，不设置则默认为-L找到的第一个协议，局域网一般是EN10MB等
-L: 列出本机支持的数据链路层协议，供-y参数使用
-c: 抓取的packet数，在处理一定数量的packet后，停止抓取，程序退出
-a: 设置tshark抓包停止向文件书写的条件，事实上是tshark在正常启动之后停止工作并返回的条件。条件写为test:value的形式，如“-a duration:5”表示tshark启动后在5秒内抓包然后停止；“-a filesize:10”表示tshark在输出文件达到10kB后停止；“-a files:n”表示tshark在写满n个文件后停止
-b: 设置ring buffer文件参数。ring buffer的文件名由-w参数决定。-b参数采用test:value的形式书写。“-b duration:5”表示每5秒写下一个ring buffer文件；“-b filesize:5”表示每达到5kB写下一个ring buffer文件；“-b files:7”表示ring buffer文件最多7个，周而复始地使用，如果这个参数不设定，tshark会将磁盘写满为止
-r: 设置tshark分析的输入文件。tshark既可以抓取分析即时的网络流量，又可以分析dump在文件中的数据。-r不能是命名管道和标准输入
-A: 使用RPCAP密码进行认证
-2: 执行两次分析
-R: 设置读取（显示）过滤表达式（read filter expression）。不符合此表达式的流量同样不会被写入文件
-Y: 使用读取过滤器的语法，在单次分析中可以代替-R选项;
-n: 禁止所有地址名字解析（默认为允许所有）
-N: 启用某一层的地址名字解析。“m”代表MAC层，“n”代表网络层，“t”代表传输层，“C”代表当前异步DNS查找。如果-n和-N参数同时存在，-n将被忽略。如果-n和-N参数都不写，则默认打开所有地址名字解析
-d: 将指定的数据按有关协议解包输出。如要将tcp 8888端口的流量按http解包，应该写为“-d tcp.port==8888,http”。注意选择子和解包协议之间不能留空格
-w: 设置raw数据的输出文件。这个参数不设置，tshark将会把解码结果输出到stdout。“-w-”表示把raw输出到stdout。如果要把解码结果输出到文件，使用重定向“>”而不要-w参数
-F: 设置输出raw数据的格式，默认为libpcap。“tshark -F”会列出所有支持的raw格式
-V: 设置将解码结果的细节输出，否则解码结果仅显示一个packet一行的summary
-O: 只显示此选项指定的协议的详细信息
-P: 即使将解码结果写入文件中，也打印包的概要信息
-E: 如果-T fields选项指定，使用-E来设置一些属性
-x: 设置在解码输出结果中，每个packet后面以HEX dump的方式显示具体数据
-T: 设置解码结果输出的格式，包括text,ps,psml和pdml，默认为text
-t: 设置解码结果的时间格式。“ad”表示带日期的绝对时间，“a”表示不带日期的绝对时间，“r”表示从第一个包到现在的相对时间，“d”表示两个相邻包之间的增量时间（delta）
-u: s|hms 格式化输出秒
-S: 在向raw文件输出的同时，将解码结果打印到控制台
-l: 在处理每个包时即时刷新输出
-X: 扩展项
-q: 设置安静的stdout输出（例如做统计时）
-z: 设置统计参数
-h: 显示命令行帮助
-v: 显示tshark的版本信息
-o: 重载选项

[tshark示例]:
# 实时打印当前http请求的url
tshark -s 512 -i eth0 -n -f "tcp dst port 80" -R "http.host and http.request.uri" -T fields -e http.host -e http.request.uri -l | tr -d "\t"

# 实时打印当前mysql查询语句
tshark -s 512 -i eth0 -n -f "tcp dst port 3306" -R "mysql.query" -T fields -e mysql.query

# 导出smpp协议header和value
tshark -r test.cap -R "(smpp.command_id==0x80000004) and (smpp.command_status==0x0)" -e smpp.message_id -e frame.time -T fields -E header=y >test.txt

# 统计http状态
tshark -n -q -z http,stat, -z http,tree

# 输出http协议的请求头，响应头，和响应数据
tshark -2 -r httpsession.pcap -R "http.request.line || http.file_data || http.response.line" -T fields -e http.request.line -e http.file_data -e http.response.line -E header=y

# 抓取500个包提取访问的网址
tshark -s 0 -i eth0 -n -f "tcp dst port 80" -R "http.host and http.request.uri" -T fields -e http.host -e http.request.uri -l -c 500

# 显示ssl data数据
tshark -n -t a -R ssl -T fields -e "ip.src" -e "ssl.app_data"

# 读取指定报文,按照ssl过滤显示内容
tshark -r temp.cap -R "ssl" -V -T text
tshark -r temp.cap -z "follow,tcp,ascii,13"

# 按照指定格式显示
tshark -r temp.cap -R ssl -Tfields -e "ip.src" -e tcp.srcport -e ip.dst -e tcp.dstport

# 输出数据
tshark -r vmx.cap -q -n -t ad -z follow,tcp,ascii,10.1.8.130:56087,10.195.4.41:446 | more

# 过滤包的时间和rtp.seq
tshark  -i eth0 -f "udp port 5004" -T fields -e frame.time_epoch -e rtp.seq -o rtp.heuristic_rtp:true 1>test.txt

# 提取各协议数据部分
tshark -r H:/httpsession.pcap -q -n -t ad -z follow,tcp,ascii,71.6.167.142:27017,101.201.42.120:59381 | more

# 分析报文封装的协议
tshark -r httpsession.pcap -T fields -e frame.number -e frame.protocols -E header=y
  '
}

function iptableshelp() {
  echo '
[iptables选项]:
-t, --table table: 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表
# 通用匹配: 源地址目标地址的匹配
-p: 指定要匹配的数据包协议类型
-s, --source [!] address[/mask]: 把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如: 192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如: 192.168.1.0/255.255.255.0
-d, --destination [!] address[/mask]: 地址格式同上，但这里是指定地址为目的地址，按此进行过滤
-i, --in-interface [!] <网络接口name>: 指定数据包的来自来自网络接口，比如最常见的 eth0 。注意: 它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，"!" 表示取反
-o, --out-interface [!] <网络接口name>: 指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用
# 查看管理命令
-L, --list [chain]: 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则
# 规则管理命令
-A, --append chain rule-specification: 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定
-I, --insert chain [rulenum] rule-specification: 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号
-D, --delete chain rule-specification -D, --delete chain rulenum: 在指定的链 chain 中删除一个或多个指定规则
-R num: Replays替换/修改第几条规则
# 链管理命令（这都是立即生效的）
-P, --policy chain target: 为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的
-F, --flush [chain]: 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则
-N, --new-chain chain: 用指定的名字创建一个新的链
-X, --delete-chain [chain]: 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链
-E, --rename-chain old-chain new-chain: 用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响
-Z, --zero [chain]: 把指定链，或者表中的所有链上的所有计数器清零
-j, --jump target <指定目标>: 即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链
-h: 显示帮助信息

[iptables表]:
raw: 高级功能，如: 网址过滤
mangle: 数据包修改（QOS），用于实现服务质量
nat: 地址转换，用于网关路由器
filter: 包过滤，用于防火墙规则

[iptables链]:
INPUT: 处理输入数据包
OUTPUT: 处理输出数据包
FORWARD: 处理转发数据包
PREROUTING: 用于目标地址转换（DNAT）
POSTOUTING: 用于源地址转换（SNAT）

[iptables动作]:
ACCEPT: 接收数据包
DROP: 丢弃数据包
REDIRECT: 重定向、映射、透明代理
SNAT: 源地址转换
DNAT: 目标地址转换
MASQUERADE: IP伪装（NAT），用于ADSL
LOG: 日志记录

[iptables示例]:
# 清空当前的所有规则和计数
iptables -F  # 清空所有的防火墙规则
iptables -X  # 删除用户自定义的空链
iptables -Z  # 清空计数

# 配置允许ssh端口连接
iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT
# 22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求

# 允许本地回环地址可以正常使用
iptables -A INPUT -i lo -j ACCEPT
# 本地圆环地址就是那个127.0.0.1，是本机上使用的,它进与出都设置为允许
iptables -A OUTPUT -o lo -j ACCEPT

# 设置默认的规则
iptables -P INPUT DROP # 配置默认的不让进
iptables -P FORWARD DROP # 默认的不允许转发
iptables -P OUTPUT ACCEPT # 默认的可以出去

# 配置白名单
iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT  # 允许机房内网机器可以访问
iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口

# 开启相应的服务端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口
iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来

# 保存规则到配置文件中
cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯
iptables-save > /etc/sysconfig/iptables
cat /etc/sysconfig/iptables

# 列出已设置的规则
iptables -L [-t 表名] [链名]
iptables -L -t nat                  # 列出 nat 上面的所有规则
iptables -L -t nat  --line-numbers  # 规则带编号
iptables -L INPUT
iptables -L -nv  # 查看，这个列表看起来更详细

# 清除已有规则
iptables -F INPUT  # 清空指定链 INPUT 上面的所有规则
iptables -X INPUT  # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。不指定则删除该表中所有非内置链
iptables -Z INPUT  # 把指定链，或者表中的所有链上的所有计数器清零。

# 删除已添加的规则
iptables -A INPUT -s 192.168.1.5 -j DROP # 添加一条规则
iptables -L -n --line-numbers # 列出带序号的规则
iptables -D INPUT 8  #删除INPUT里序号为8的规则

# 开放指定的端口
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即运行本机访问本机)
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行
iptables -A OUTPUT -j ACCEPT      # 允许所有本机向外的访问
iptables -A INPUT -p tcp --dport 22 -j ACCEPT    # 允许访问22端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    # 允许访问80端口
iptables -A INPUT -p tcp --dport 21 -j ACCEPT    # 允许ftp服务的21端口
iptables -A INPUT -p tcp --dport 20 -j ACCEPT    # 允许FTP服务的20端口
iptables -A INPUT -j reject       # 禁止其他未允许的规则访问
iptables -A FORWARD -j REJECT     # 禁止其他未允许的规则访问

# 屏蔽端口
iptables -A INPUT -p tcp --dport 12345 -j DROP  # 屏蔽访问 12345 端口

# 屏蔽域名
iptables -A OUTPUT -m string --string "foo.bar" --algo bm --to 65535 -j DROP  # 屏蔽服务器内域名访问

# 屏蔽IP
iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP  # 屏蔽恶意主机（比如，192.168.0.8
iptables -I INPUT -s 123.45.6.7 -j DROP       # 屏蔽单个IP的命令
iptables -I INPUT -s 123.0.0.0/8 -j DROP      # 封整个段即从123.0.0.1到123.255.255.254的命令
iptables -I INPUT -s 124.45.0.0/16 -j DROP    # 封IP段即从123.45.0.1到123.45.255.254的命令
iptables -I INPUT -s 123.45.6.0/24 -j DROP    # 封IP段即从123.45.6.1到123.45.6.254的命令

# 指定数据包出去的网络接口
iptables -A FORWARD -o eth0  #只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用

# 查看已添加的规则
iptables -L -n -v

# 启动网络转发规则
iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127  #公网210.14.67.7让内网192.168.188.0/24上网

# 端口映射
iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222  -j DNAT --to-dest 192.168.188.115:22  #本机的2222端口映射到内网虚拟机的22端口

# 字符串匹配
iptables -A INPUT -p tcp -m string --algo kmp --string "test" -j REJECT --reject-with tcp-reset  # 终止所有带字符串test的TCP连接

# 阻止Windows蠕虫的攻击
iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string "cmd.exe"

# 防止SYN洪水攻击
iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT
  '
}

function nmaphelp() {
  echo '
[nmap选项]:
-iL: 指定输入文件, 可用于指定扫描的目标
-iR: 选择随机目标
–exclude: 排除主机, 即扫描的时候越过该主机
–excludefile: 通过黑名单文件指定排除的主机
-sL: 显示扫描主机的列表
-sn: 使用ping进行扫描
-Pn: 不进行主机发现, 直接进行深层扫描, 使用此命令时, nmap认为主机在线
-PS: 端口列表用,隔开[tcp80 syn 扫描]
-PA: 端口列表用,隔开ack扫描【默认扫描端口1-1024】
-PU: 端口列表用,隔开[udp高端口扫描 穿越只过滤tcp的防火墙]
-PE: 通过ICMP Echo扫描简单来说是通过向目标发送ICMP Echo数据包来探测目标主机是否存活, 但由于许多主机的防火墙会禁止这些报文, 所以仅仅ICMP扫描通常是不够的
-PP: 通过ICMP time stamp时间戳扫描在大多数防火墙配置不当时可能会得到回复, 可以以此方式来判断目标主机是否存活。倘若目标主机在线, 该命令还会探测其开放的端口以及运行的服务
-PM: 通过ICMP address maskPing地址掩码扫描会试图用备选的ICMP等级Ping指定主机, 通常有不错的穿透防火墙的效果
-PO: 进行一个基于指定的IP协议的ping
-n/-R: 选择是否进行dns解析
–dns-servers: 明确使用的DNS服务器
-system-dns: 使用主机nmap运行主机的dns
–traceroute: 跟踪扫描主机的网络路线
-sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans, 指定nmap的扫描方式, 默认为sT
-sU: 使用UDP协议进行扫描
-sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态
–scanflags: 定制TCP包的flags
-sI: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）
-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况
-sO: 使用IP protocol 扫描确定目标机支持的协议类型
-b: 使用FTP bounce scan扫描方式
-p: Only scan specified ports
–exclude-ports: 排除指定端口不作扫描
-F: 快速模式, 仅扫描TOP 100的端口
-r: 不进行端口随机打乱的操作（如无该参数, nmap会将要扫描的端口以随机顺序方式扫描, 以让nmap的扫描不易被对方防火墙检测到）
–top-ports: 扫描开放概率最高的number个端口（nmap的作者曾经做过大规模地互联网扫描, 以此统计出网络上各种端口可能开放的概率
–port-ratio: 扫描指定频率以上的端口。与上述–top-ports类似, 这里以概率作为参数, 让概率大于–port-ratio的端口才被扫描
-sV: 指定让Nmap进行版本侦测
–version-intensity: 指定版本侦测强度（0-9）, 默认为7, 数值越高, 探测出的服务越准确, 但是运行时间会比较长
–version-light: 指定使用轻量侦测方式 (intensity 2)
–version-all: 尝试使用所有的probes进行侦测 (intensity 9)
–version-trace: 显示出详细的版本侦测过程信息
-sC: 指定script脚本为默认值
–script: 使用某个或某类脚本进行扫描, 支持通配符描述
–script-args: 为脚本提供默认参数
–script-args-file: 使用文件来为脚本提供参数
–script-trace: 显示脚本执行过程中发送与接收的数据
–script-updatedb: 更新脚本数据库, 每次更新脚本后
–script-help: 显示脚本的帮助信息, 其中部分可以逗号分隔的文件或脚本类别
-O: 指定Nmap进行OS侦测
–osscan-limit: 限制Nmap只对确定的主机的进行OS探测（至少需确知该主机分别有一个open和closed的端口）
–osscan-guess: 大胆猜测对方的主机的系统类型。由此准确性会下降不少, 但会尽可能多为用户提供潜在的操作系统
-T<0-5>: 扫描效率, 越高越快
–min-hostgroup/max-hostgroup: 平行的主机扫描组的大小
–min-parallelism/max-parallelism: 并行探测
–min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout: 指定每轮探测的时间
–max-retries: 扫描探测的上限次数设定
–host-timeout: 设置timeout时间
–scan-delay/–max-scan-delay: 调整两次探测之间的延迟
–min-rate: 每秒发送数据包不少于次
–max-rate: 每秒发送数据包不多于次
-f; --mtu: 指定使用分片、指定数据包的MTU.
-D: 用一组IP地址掩盖真实地址, 其中ME填入自己的IP地址
-S: 伪装成其他IP地址
-e: 使用特定的网络接口,指定网卡
-g/–source-port: 使用指定源端口
–proxies: 使用代理
–data: 给数据包添加指定数据
–data-string: 给数据包添加指定ASCII字符串
–data-length: 填充随机数据让数据包长度达到Num
–ip-options: 使用指定的IP选项来发送数据包。
–ttl: 设置time-to-live时间,没什么用
–spoof-mac: 伪装MAC地址, 伪装mac地址为指定值
–badsum: 使用错误的checksum来发送数据包（正常情况下, 该类数据包被抛弃, 如果收到回复, 说明回复来自防火墙或IDS/IPS）
-oN/-oX/-oS/-oG: 指定输出文件格式
-oA: 用生成以上格式的文件
-v: 这个选项使用两次, 会提供更详细的信息
-d: 提高或设置调试级别, 最高级别-d9, 输出更多的细节
–reason: 显示端口处于特定状态的原因
–open: 仅显示open的端口
–packet-trace: 显示所有的收发包
–iflist: 打印主机网络接口和路由
–append-output: 以追加的形式写入文件
–resume: 重新开始中断的扫描
–stylesheet: 指定xsl样式文件将xml转换为html
–webxml: 参考在线样式表
–no-stylesheet: 防止关联带有xml输出的样式表
-6: 启用IPv6扫描
-A: 启用OS检测, 版本检测, 脚本扫描和路由跟踪
–datadir: 指定自定义nmap数据文件路径
–send-eth/–send-ip: 使用原始以太网帧或ip数据包发送
–privileged: 假设用户具有完全特权
–unprivileged: 假设用户缺乏原始套接字特权
-V: 打印版本号
-h: 打印帮助摘要

[nmap示例]:
# 扫描并输出数据库信息
nmap -sS -p 1433,1434 -f --script ms-sql-info  -oG - -oX ms-sql.xml 110.42.96.0/24

# 爆破数据库
nmap -sT -p 1433,1434 -f --script ms-sql-brute -script-args userdb=sqluser.dic,passdb=sqlpass.dic -oG - -oX ms-sql-test.xml 110.42.96.0/24

# 获取远程主机的系统类型及开放端口
nmap -sS -P0 -sV -O 110.42.96.0

# 列出开放了指定端口的主机列表
nmap -sT -p 80 -oG – 192.168.1.* | grep open

# 在网络寻找所有在线主机
nmap -sP 192.168.0.*
nmap -sP 192.168.0.0/24

# Ping指定范围内的IP地址
nmap -sP 192.168.1.100-254

# 在某段子网上查找未占用的IP
nmap -T4 -sP 192.168.2.0/24 && egrep “00:00:00:00:00:00″ /proc/net/arp

# 在局域网上扫找Conficker蠕虫病毒
nmap -PN -T4 -p139,445 -n -v –script=smb-check-vulns –script-args safe=1 192.168.0.1-254

# 扫描网络上的恶意接入点rogue APs
nmap -A -p1-85,113,443,8080-8100 -T4 –min-hostgroup 50 –max-rtt-timeout2000 –initial-rtt-timeout 300 –max-retries 3 –host-timeout 20m–max-scan-delay 1000 -oA wapscan 10.0.0.0/8

# 使用诱饵扫描方法来扫描主机端口
nmap -sS 192.168.0.10 -D 192.168.0.2

# 为一个子网列出反向DNS记录
nmap -R -sL 209.85.229.99/27 | awk "{if($3=="not")print"("$2") no PTR";else print$3" is "$2}" | grep "("

# 显示网络上共有多少台Linux及Win设备
nmap -F -O 192.168.0.1-255 | grep "Running: " > /tmp/os; echo "$(cat /tmp/os | grep Linux \| wc -l) Linux device(s)"; echo "$(cat /tmp/os | grep Windows | wc -l) Window(s) device"

# 探测Web应用错误代码
nmap -p80,443 --script http-errors targetWebsite.com

# 爆破子域
nmap -p80,443 --script dns-brute targetWebsite.com
nmap -p80,443 --script dns-brute --script-args dns-brute.threads=25,dns-brute.hostlist=/root/Desktop/custom-subdomain-wordlist.txt targetWebsite.com

# 爬取Web应用
nmap -vv -p80,443 --script http-errors --script-args "httpspider.url=/docs/,httpspider.maxpagecount=3,httpspider.maxdepth=1" targetwebsite.com

# 探测Web应用防火墙以及防火墙指纹检测
nmap -p80,443 --script http-waf-detect --script-args "http-waf-detect.aggro,http-waf-detect.detectBodyChanges" targetWebsite.com
nmap -p80,443 --script http-waf-fingerprint targetWebsite.comStarting 
nmap -p80,443 --script http-waf-fingerprint --script-args http-waf-fingerprint.intensive=1 targetWebsiteStarting

# 提取图片嵌入式信息EXIF
nmap -p80,443 --script http-exif-spider targetWebsite.com
nmap -p80,443 --script http-exif-spider --script-args "http.max-cache-size=99999999" targetWebsite.com
  '
}

function mysqlhelp() {
  echo "
[mysql选项]:
-?, --help: 显示帮助信息并退出
-I, --help: 显示帮助信息并退出
--auto-rehash: 自动补全功能，就像linux里面，按Tab键出提示差不多，下面有例子
-A, --no-auto-rehash: 默认状态是没有自动补全功能的。-A就是不要自动补全功能
-B, --batch: sql不使用历史文件，禁用交互
--character-sets-dir=name: 字体集的安装目录                    
--default-character-set=name: 设置数据库的默认字符集
-C, --compress: 在客户端和服务器端传递信息时使用压缩
-#, --debug[=#]: bug调用功能
-D, --database=name: 使用哪个数据库
--delimiter=name: mysql默认命令结束符是分号，下面有例子
-e, --execute=name: 执行mysql的sql语句
-E, --vertical: 垂直打印查询输出
-f, --force: 如果有错误跳过去，继续执行下面的
-G, --named-commands: 在query中启用内部命令
-g, --no-named-commands: 早query中禁用内部命令
-i, --ignore-spaces: 忽视函数名后面的空格.
--local-infile: 启动/禁用 LOAD DATA LOCAL INFILE.
-b, --no-beep: sql错误时，禁止嘟的一声
-h, --host=name: 设置连接的服务器名或者Ip
-H, --html: 以html的方式输出
-X, --xml: 以xml的方式输出
--line-numbers: 显示错误的行号
-L, --skip-line-numbers: 忽略错误的行号
-n, --unbuffered: 每执行一次sql后，刷新缓存
--column-names: 查寻时显示列信息，默认是加上的
-N, --skip-column-names: 不显示列信息
-O, --set-variable=name: 设置变量用法是--set-variable=var_name=var_value
--sigint-ignore: 忽视SIGINT符号(登录退出时Control-C的结果)
-o, --one-database: 忽视除了为命令行中命名的默认数据库的语句。可以帮跳过日志中的其它数据库的更新。
--pager[=name]: 使用分页器来显示查询输出，这个要在linux可以用more,less等。
--no-pager: 不使用分页器来显示查询输出。
-p, --password[=name]: 输入密码
-P, --port=#: 设置端口
--prompt=name: 设置mysql提示符
--protocol=name: 使用什么协议
-q, --quick: 不缓存查询的结果，顺序打印每一行。如果输出被挂起，服务器会慢下来，mysql不使用历史文件。
-r, --raw: 写列的值而不转义转换。通常结合--batch选项使用。
--reconnect: 如果与服务器之间的连接断开，自动尝试重新连接。禁止重新连接，使用--disable-reconnect。
-s, --silent: 一行一行输出，中间有tab分隔
-S, --socket=name: 连接服务器的sockey文件
--ssl: 激活ssl连接，不激活--skip-ssl
--ssl-ca=name: CA证书
--ssl-capath=name: CA路径
--ssl-cert=name: X509 证书
--ssl-cipher=name: SSL cipher to use (implies --ssl).
--ssl-key=name: X509 密钥名
--ssl-verify-server-cert: 连接时审核服务器的证书
-t, --table: 以表格的形势输出
--tee=name: 将输出拷贝添加到给定的文件中，禁时用--disable-tee
--no-tee: 根--disable-tee功能一样
-u, --user=name: 用户名
-U, --safe-updates: Only allow UPDATE and DELETE that uses keys.
-U, --i-am-a-dummy: Synonym for option --safe-updates, -U.
-v, --verbose: 输出mysql执行的语句
-V, --version: 版本信息
-w, --wait: 服务器down后，等待到重起的时间
--connect_timeout=#: 连接前要等待的时间
--max_allowed_packet=#: 服务器接收／发送包的最大长度
--net_buffer_length=#: TCP/IP和套接字通信缓冲区大小。
--select_limit=#: 使用--safe-updates时SELECT语句的自动限制
--max_join_size=#: 使用--safe-updates时联接中的行的自动限制
--secure-auth: 拒绝用(pre-4.1.1)的方式连接到数据库
--server-arg=name: Send embedded server this as a parameter.
--show-warnings: 显示警告

[mysql工具]:
myisampack: 压缩MyISAM表以产生更小的只读表的一个工具
mysql: 交互式输入SQL语句或从文件经批处理模式执行它们的命令行工具
mysqlacceess: 检查访问主机名、用户名和数据库组合的权限的脚本
mysqladmin: 执行管理操作的客户程序，例如创建或删除数据库、重载授权表、将表刷新到硬盘上、重新打开日志文件以及检索版本、进程以及服务器的状态信息
mysqlbinlog: 从二进制日志读取语句，在二进制日志文件中包含执行过的语句，可用来帮助系统从崩溃中恢复
mysqlcheck: 检查、修复、分析以及优化表的表维护客户程序
mysqldump: 将MySQL数据库转储到一个文件（例如SQL语句或Tab分隔符文本文件）的客户程序
mysqlhotcopy: 当服务器在运行时，快速备份MyISAM或ISAM表的工具
mysqlimport: 使用LOAD DATA INFILE 将文本文件导入相应的客户程序
mysqlshow: 显示数据库、表、列以及索引相关信息的客户程序
perror: 显示系统或MySQL错误代码含义的工具

[mysql示例]:
#检测mysql server是否正常提供服务
mysqladmin -u sky -ppwd -h localhost ping

#获取mysql当前的几个状态值
mysqladmin -u sky -ppwd -h localhost status

#获取数据库当前的连接信息
mysqladmin -u sky -ppwd -h localhost processlist

#获取当前数据库的连接数
mysql -u root -p123456 -BNe 'select host,count(host) from processlist group by host;' information_schema

#显示mysql的uptime
mysql -e \"SHOW STATUS LIKE '%uptime%'\"|awk '/ptime/{ calc = \$NF / 3600;print \$(NF-1), calc\"Hour\" }'

#查看数据库的大小
mysql -u root -p123456-e 'select table_schema,round(sum(data_length+index_length)/1024/1024,4) from information_schema.tables group by table_schema;'

#查看某个表的列信息
mysql -u <user> --password=<password> -e \"SHOW COLUMNS FROM <table>\" <database> | awk '{print \$1}' | tr \"\n\" \",\" | sed 's/,\$//g'

#执行mysql脚本
mysql -u user-name -p password < script.sql

#mysql dump数据导出
mysqldump -uroot -T/tmp/mysqldump test test_outfile --fields-enclosed-by=\\\" --fields-terminated-by=,

#mysql数据导入
mysqlimport --user=name --password=pwd test --fields-enclosed-by=\\\" --fields-terminated-by=, /tmp/test_outfile.txt
LOAD DATA INFILE '/tmp/test_outfile.txt' INTO TABLE test_outfile FIELDS TERMINATED BY '\"' ENCLOSED BY ',';

#mysql进程监控
ps -ef | grep 'mysqld_safe' | grep -v 'grep'
ps -ef | grep 'mysqld' | grep -v 'mysqld_safe'| grep -v 'grep'

#查看当前数据库的状态
mysql -u root -p123456 -e 'show status'

#mysqlcheck 工具程序可以检查(check),修 复( repair),分 析( analyze)和优化(optimize)MySQL Server 中的表
mysqlcheck -u root -p123456 --all-databases

#mysql qps查询  QPS = Questions(or Queries) / Seconds
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Questions\"'
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Queries\"'

#mysql Key Buffer 命中率  key_buffer_read_hits = (1 - Key_reads / Key_read_requests) * 100%  key_buffer_write_hits= (1 - Key_writes / Key_write_requests) * 100%
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Key%\"'

#mysql Innodb Buffer 命中率  innodb_buffer_read_hits=(1-Innodb_buffer_pool_reads/Innodb_buffer_pool_read_requests) * 100%
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Innodb_buffer_pool_read%\"'

#mysql Query Cache 命中率 Query_cache_hits= (Qcache_hits / (Qcache_hits + Qcache_inserts)) * 100%
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Qcache%\"'

#mysql Table Cache 状态量
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Open%\"'

#mysql Thread Cache 命中率  Thread_cache_hits = (1 - Threads_created / Connections) * 100%  正常来说,Thread Cache 命中率要在 90% 以上才算比较合理。
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Thread%\"'

#mysql 锁定状态:锁定状态包括表锁和行锁两种,我们可以通过系统状态变量获得锁定总次数,锁定造成其他线程等待的次数,以及锁定等待时间信息
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"%lock%\"'

#mysql 复制延时量 在slave节点执行
mysql -u root -p123456 -e 'SHOW SLAVE STATUS'

#mysql Tmp table 状况 Tmp Table 的状况主要是用于监控 MySQL 使用临时表的量是否过多,是否有临时表过大而不得不从内存中换出到磁盘文件上
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Created_tmp%\"'

#mysql Binlog Cache 使用状况:Binlog Cache 用于存放还未写入磁盘的 Binlog 信 息 。
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Binlog_cache%\"'

#mysql nnodb_log_waits 量:Innodb_log_waits 状态变量直接反应出 Innodb Log Buffer 空间不足造成等待的次数
mysql -u root -p123456 -e 'SHOW /*!50000 GLOBAL */ STATUS LIKE \"Innodb_log_waits\"'
  "
}

function main() {
  if [ -z "$1" ]; then
    usage simple
    exit 1
  elif [ "$1" == "--" ]; then
    usage simple
    exit 0
  elif [ "$1" == "--help" ]; then
    usage
    exit 0
  elif [ "$1" == "print" ]; then
    cat $(echo $0)
  elif [ "$1" == "g" ] || [ "$1" == "go" ]; then
    require go
    shift
    go $*
  elif [ "$1" == "lg" ] || [ "$1" == "lgo" ]; then
    require go
    shift
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go $*
  elif [ "$1" == "git" ]; then
    require git
    shift
    git $*
  elif [ "$1" == "h" ] || [ "$1" == "hm" ] || [ "$1" == "helm" ]; then
    require helm
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      helmhelp
    elif [ "$1" == "help" ]; then
      require helm
      helm --help
    elif [ "$1" == "t" ] || [ "$1" == "temp" ] || [ "$1" == "template" ]; then
      shift
      helm template $*
    elif [ "$1" == "s" ] || [ "$1" == "search" ]; then
      shift
      helm search $*
    elif [ "$1" == "sh" ] || [ "$1" == "shub" ] || [ "$1" == "searchhub" ]; then
      shift
      helm search hub $*
    elif [ "$1" == "p" ] || [ "$1" == "pkg" ] || [ "$1" == "package" ]; then
      shift
      helm package $*
    elif [ "$1" == "i" ] || [ "$1" == "inst" ] || [ "$1" == "install" ]; then
      shift
      helm install $*
    elif [ "$1" == "u" ] || [ "$1" == "upd" ] || [ "$1" == "upgrade" ]; then
      shift
      helm upgrade $*
    elif [ "$1" == "d" ] || [ "$1" == "del" ] || [ "$1" == "delete" ]; then
      shift
      helm delete $*
    elif [ "$1" == "c" ] || [ "$1" == "crt" ] || [ "$1" == "create" ]; then
      shift
      helm create $*
    elif [ "$1" == "f" ] || [ "$1" == "pull" ] || [ "$1" == "fetch" ]; then
      shift
      helm fetch $*
    elif [ "$1" == "l" ] || [ "$1" == "lst" ] || [ "$1" == "list" ]; then
      shift
      helm list $*
    elif [ "$1" == "v" ] || [ "$1" == "vfy" ] || [ "$1" == "verify" ]; then
      shift
      helm verify $*
    elif [ "$1" == "r" ] || [ "$1" == "rp" ] || [ "$1" == "repo" ]; then
      shift
      helm repo $*
    elif [ "$1" == "a" ] || [ "$1" == "sts" ] || [ "$1" == "status" ]; then
      shift
      helm status $*
    else
      helm $*
    fi
  elif [ "$1" == "ht" ]; then
    require helm
    shift
    helm template $*
  elif [ "$1" == "kd" ]; then
    require kind
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      kindhelp
    elif [ "$1" == "help" ]; then
      kind help
    elif [ "$1" == "cl" ] || [ "$1" == "ls" ] || [ "$1" == "list" ]; then
      kind get clusters
    elif [ "$1" == "info" ]; then
      kubectl cluster-info 
    elif [ "$1" == "ssl" ] || [ "$1" == "pki" ]; then
      dest="."
      if [ $# -gt 1 ]; then
        dest=$2
      fi
      docker cp $(kind get nodes|grep control-plane|sed -n '1p'):/etc/kubernetes/$1 $dest
    elif [ "$1" == "ac" ] || [ "$1" == "completion" ]; then
      shift
      shl="bash"
      if [ $# -gt 0 ]; then
        shl="$1"
      fi
      if [ "$shl" == "bash" ]; then
        kind completion bash > ~/.kind-completion
        source ~/.kind-completion
      elif [ "$shl" == "zsh" ]; then
        mkdir -p /usr/local/share/zsh/site-functions/
        kind completion zsh > /usr/local/share/zsh/site-functions/_kind
        zsh -c "autoload -U compinit && compinit"
      elif [ "$shl" == "fish" ]; then
        kind completion fish > ~/.config/fish/completions/kind.fish
      fi
    elif [ "$1" == "ld" ] || [ "$1" == "load" ]; then
      shift
      if [ $# -ge 1 ]; then
        cname="kind"
        if [ $# -gt 1 ]; then
          cname="$2"
        fi
        if [ "${1##*.}" == "gz" ] || [ "${1##*.}" == "tar" ] || [ "${1##*.}" == "zip" ]; then
          kind load image-archive $1 --name $cname
        else 
          kind load docker-image $1 --name $cname
        fi
      fi
    elif [ "$1" == "d" ] || [ "$1" == "dc" ]; then
      shift
      docker exec $(kind get nodes|grep control-plane|sed -n '1p') crictl $*
    elif [ "$1" == "l" ] || [ "$1" == "log" ]; then
      shift
      if [ $# -eq 0 ]; then
        cids=$(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q)
        if [ $(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q | wc -l) -lt 2 ]; then
          cid=$cids
        else
          echo "====== More than one container ======"
          SIFS=$IFS
          IFS=$'\n'
          cids=($cids)
          IFS=$SIFS
          for ((i = 0; i < ${#cids[@]}; i++)); do
            echo "$i: ${cids[$i]}"
          done
          read -p "====== select one with number[0]: " kcdidx
          if [ -z "$kcdidx" ]; then
            kcdidx=0
          fi
          cid=$(echo ${cids[$kcdidx]})
        fi
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl logs ${cid:0:12}
      else
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl logs $1
      fi
    elif [ "$1" == "lf" ] || [ "$1" == "logf" ]; then
      shift
      if [ $# -eq 0 ]; then
        cids=$(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q)
        if [ $(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q | wc -l) -lt 2 ]; then
          cid=$cids
        else
          echo "====== More than one container ======"
          SIFS=$IFS
          IFS=$'\n'
          cids=($cids)
          IFS=$SIFS
          for ((i = 0; i < ${#cids[@]}; i++)); do
            echo "$i: ${cids[$i]}"
          done
          read -p "====== select one with number[0]: " kcdidx
          if [ -z "$kcdidx" ]; then
            kcdidx=0
          fi
          cid=$(echo ${cids[$kcdidx]})
        fi
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl logs -f ${cid:0:12}
      else
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl logs -f $1
      fi
    elif [ "$1" == "i" ] || [ "$1" == "ie" ] || [ "$1" == "iexe" ]; then
      shift
      if [ $# -eq 0 ]; then
        cids=$(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q)
        if [ $(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q | wc -l) -lt 2 ]; then
          cid=$cids
        else
          echo "====== More than one container ======"
          SIFS=$IFS
          IFS=$'\n'
          cids=($cids)
          IFS=$SIFS
          for ((i = 0; i < ${#cids[@]}; i++)); do
            echo "$i: ${cids[$i]}"
          done
          read -p "====== select one with number[0]: " kcdidx
          if [ -z "$kcdidx" ]; then
            kcdidx=0
          fi
          cid=$(echo ${cids[$kcdidx]})
        fi
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl exec -it ${cid:0:12} sh
      elif [ $# -eq 1 ]; then
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl exec -it $1 sh
      else
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl exec -it $1 $2
      fi
    elif [ "$1" == "e" ] || [ "$1" == "exe" ]; then
      shift
      if [ $# -eq 1 ]; then
        cids=$(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q)
        if [ $(docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl ps -q | wc -l) -lt 2 ]; then
          cid=$cids
        else
          echo "====== More than one container ======"
          SIFS=$IFS
          IFS=$'\n'
          cids=($cids)
          IFS=$SIFS
          for ((i = 0; i < ${#cids[@]}; i++)); do
            echo "$i: ${cids[$i]}"
          done
          read -p "====== select one with number[0]: " kcdidx
          if [ -z "$kcdidx" ]; then
            kcdidx=0
          fi
          cid=$(echo ${cids[$kcdidx]})
        fi
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl exec ${cid:0:12} $*
      else
        docker exec -it $(kind get nodes|grep control-plane|sed -n '1p') crictl exec $*
      fi
    elif [ "$1" == "rm" ] || [ "$1" == "del" ] || [ "$1" == "delete" ]; then
      shift
      if [ $# -gt 0 ]; then
        for kdc in $@; do
          kind delete cluster --name $kdc
        done
      elif [ $(kind get clusters | wc -l) -lt 2 ]; then
        kind delete cluster --name $(kind get clusters)
      else
        echo "====== More than one cluster ======"
        kdcs=$(kind get clusters)
        SIFS=$IFS
        IFS=$'\n'
        kdcs=($kdcs)
        IFS=$SIFS
        for ((i = 0; i < ${#kdcs[@]}; i++)); do
          echo "$i: ${kdcs[$i]}"
        done
        read -p "====== select one with number[0]: " kdidx
        if [ -z "$kdidx" ]; then
          kdidx=0
        fi
        kind delete cluster --name $(echo ${kdcs[$kdidx]})
      fi
    elif [ $# -le 1 ]; then
      # genKindConfig
      if [ -z "$1" ]; then
cat <<EOF | kind create cluster --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  #image: kindest/node:v1.17.11@sha256:5240a7a2c34bf241afb54ac05669f8a46661912eab05705d660971eeb12f6555
  image: kindest/node:v1.21.1@sha256:69860bda5563ac81e3c0057d654b5253219618a22ec3a346306239bba8cfa1a6
  extraPortMappings:
  - containerPort: 2379
    hostPort: 23790
EOF
      else
        reg_name='registry'
        reg_port='5000'
        running="$(docker inspect -f '{{.State.Running}}' "${reg_name}" 2>/dev/null || true)"
        if [ "${running}" != 'true' ]; then
            docker run -d --restart=always -p "${reg_port}:5000" --name "${reg_name}" registry:2
        fi

        # create a cluster with the local registry enabled in containerd
cat <<EOF | kind create cluster --name=$1 --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
containerdConfigPatches:
- |-
  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."localhost:${reg_port}"]
    endpoint = ["http://${reg_name}:${reg_port}"]
nodes:
- role: control-plane
  #image: kindest/node:v1.17.11@sha256:5240a7a2c34bf241afb54ac05669f8a46661912eab05705d660971eeb12f6555
  image: kindest/node:v1.21.1@sha256:69860bda5563ac81e3c0057d654b5253219618a22ec3a346306239bba8cfa1a6
  extraPortMappings:
  - containerPort: 2379
    hostPort: 23790
EOF

        docker network connect "kind" "${reg_name}"

        for node in $(kind get nodes --name $1); do
            kubectl annotate node "${node}" "kind.x-k8s.io/registry=localhost:${reg_port}";
        done
      fi
    else
      kind $*
    fi
  elif [ "$1" == "kk" ]; then
    require kubectl
    shift
    kubectl kustomize $*
  elif [ "$1" == "km" ] || [ "$1" == "kustomize" ]; then
    require kustomize
    shift
    kustomize $*
  elif [ "$1" == "ec" ] || [ "$1" == "edc" ] || [ "$1" == "etcdctl" ]; then
    require etcdctl
    shift
    ETCDCTL_API=3 etcdctl $*
  elif [ "$1" == "py" ] || [ "$1" == "py3" ] || [ "$1" == "python" ] || [ "$1" == "python3" ]; then
    shift
    if type python3 &>/dev/null; then
      python3 $*
    else
      python $*
    fi
  elif [ "$1" == "ch" ] || [ "$1" == "chp" ]; then
    shift
    xdg-open https://man.linuxde.net/$1
  elif [ "$1" == "ldf" ]; then
    shift
    if type dfc &>/dev/null; then
      dfc | grep "$1"
    else
      require df column
      df -hP | column -t | grep "$1"
    fi
  elif [ "$1" == "lfd" ]; then
    shift
    require awk
    awk 'BEGIN{split("B K M G T P E Z Y",v)} {if ($NF ~ "^[a-zA-Z].*[0-9]$" && $NF !~ "c[0-9]+d[0-9]+$" && $NF !~ "^loop.*"){s=1;while($((NF-1))>1024&&s<9){$((NF-1))/=1024;s++} printf "%7.2f%s\tdev/%s\n",$((NF-1)),v[s+1],$NF}}' /proc/partitions
  elif [ "$1" == "ldu" ]; then
    require du sort awk
    shift
    if [ $# -eq 0 ]; then
      lpath="."
    else
      if [[ $1 =~ /$ ]]; then
        lpath=${1%/*}
      else
        lpath=$1
      fi
    fi
    #cd $lpath
#     if [ $(ls -d .{[!.],.?}* 2>/dev/null | wc -l) -gt 0 ]; then
#       du -sb $lpath/* $lpath/.[^.]* | sort -nr | awk 'BEGIN{split("B K M G T P E Z Y",v)} {s=1;while($1>1024&&s<9){$1/=1024;s++}printf "%7.2f%s\t%s\n",$1,v[s],$2}'
#     else
#       du -sb $lpath/* | sort -nr | awk 'BEGIN{split("B K M G T P E Z Y",v)} {s=1;while($1>1024&&s<9){$1/=1024;s++}printf "%7.2f%s\t%s\n",$1,v[s],$2}'
#     fi
    du -sb $lpath/* | sort -nr | awk 'BEGIN{split("B K M G T P E Z Y",v)} {s=1;while($1>1024&&s<9){$1/=1024;s++}printf "%7.2f%s\t%s\n",$1,v[s],$2}'
    # du -sh $lpath
  elif [ "$1" == "lkl" ]; then
    require dmesg
    dmesg $*
  elif [ "$1" == "ljc" ]; then
    require journalctl
    journalctl $*
  elif [ "$1" == "ldd" ]; then
    require ldd
    ldd $*
  elif [ "$1" == "so" ]; then
    require objdump
    objdump -TC $*
    #readelf -Ws $*
    #nm -gD $*
  elif [ "$1" == "st" ]; then
    shift
    if [ "$1" == "c" ] || [ "$1" == "cpu" ]; then
      cat /proc/cpuinfo
    elif [ "$1" == "m" ] || [ "$1" == "mem" ]; then
      cat /proc/meminfo
    elif [ "$1" == "ctp" ] || [ "$1" == "ctop" ]; then
      shift
      require ctop
      ctop $*
    elif [ "$1" == "tp" ] || [ "$1" == "top" ]; then
      shift
      if type gotop &>/dev/null; then
        gotop $*
      elif type htop &>/dev/null; then
        htop $*
      else
        top $*
      fi
    elif [ "$1" == "io" ]; then
      shift
      require iostat
      iostat $*
    elif [ "$1" == "vm" ]; then
      shift
      require vmstat
      vmstat $*
    elif [ "$1" == "mp" ]; then
      shift
      require mpstat
      mpstat $*
    elif [ "$1" == "net" ]; then
      shift
      require netstat
      if [ $# -eq 0 ]; then
        netstat -vatunlp
      else
        netstat $*
      fi
    elif [ "$1" == "pid" ]; then
      shift
      require pidstat
      if [ "$1" == "c" ]; then
        pidstat -u
      elif [ "$1" == "m" ]; then
        pidstat -r
      elif [ "$1" == "d" ]; then
        pidstat -d
      elif [ "$1" == "w" ]; then
        pidstat -w
      elif [ "$1" == "t" ]; then
        pidstat -t
      else
        pidstat $*
      fi
    elif [ "$1" == "java" ]; then
      shift
      if [ "$1" == "dump" ]; then
        javadump
      elif [ "$1" == "jps" ]; then
        shift
        require jps
        jps $*
      elif [ "$1" == "jstat" ]; then
        shift
        require jstat
        jstat $*
      elif [ "$1" == "jmap" ]; then
        shift
        require jmap
        jmap $*
      elif [ "$1" == "jhat" ]; then
        shift
        require jhat
        jhat $*
      elif [ "$1" == "jstack" ]; then
        shift
        require jstack
        jstack $*
      elif [ "$1" == "jinfo" ]; then
        shift
        require jinfo
        jinfo $*
      else
        require java
        java $*
      fi
    elif [ "$1" == "mysql" ]; then
      shift
      if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
        mysqlhelp
      elif [ "$1" == "help" ]; then
        require mysql
        mysql --help
      else
        require mysql
        mysql $*
      fi
    fi
  elif [ "$1" == "td" ] || [ "$1" == "tdp" ] || [ "$1" == "tcpdump" ]; then
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      tcpdumphelp
    elif [ "$1" == "help" ]; then
      require tcpdump
      tcpdump --help
    else
      require tcpdump
      tcpdump $*
    fi
  elif [ "$1" == "ts" ] || [ "$1" == "tsk" ] || [ "$1" == "tshark" ]; then
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      tsharkhelp
    elif [ "$1" == "help" ]; then
      require tshark
      tshark --help
    else
      require tshark
      tshark $*
    fi
  elif [ "$1" == "nm" ] || [ "$1" == "nmap" ]; then
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      nmaphelp
    elif [ "$1" == "help" ]; then
      require nmap
      nmap --help
    else
      require nmap
      if [ $# -eq 1 ]; then
        sudo nmap -sS -P0 -sV -O $1
      else
        nmap $*
      fi
    fi
  elif [ "$1" == "pc" ] || [ "$1" == "portctl" ] || [ "$1" == "portcontrol" ]; then
    shift
    if [ $# -lt 1 ]; then
      echo "error: need arguments"
    fi
    if [ "$1" == "open" ] || [ "$1" == "accept" ]; then
      paction="ACCEPT"
    elif [ "$1" == "close" ] || [ "$1" == "drop" ]; then
      paction="DROP"
    else
      paction="DROP"
    fi
    shift
    for pport in $*; do
      sudo /sbin/iptables -I INPUT -p tcp --dport $pport -j $paction
    done
  elif [ "$1" == "pt" ] || [ "$1" == "pst" ] || [ "$1" == "pstree" ]; then
   require ps
   ps -alfx | grep -- " $(ps -o ppid= $2) \| $2 " | grep -v "grep" 
  elif [ "$1" == "ps" ] || [ "$1" == "portstat" ] || [ "$1" == "portstatus" ]; then
    shift
    if [ $# -eq 1 ]; then
      nhost="127.0.0.1"
      nport=$1
    elif [ $# -gt 1 ]; then
      nhost=$1
      nport=$2
    else
      echo "error: need arguments"
    fi
    if type nc &>/dev/null; then
      nc -zv $nhost $nport
    elif type telnet &>/dev/null; then
      echo -e '\035\nquit' | telnet $nhost $nport
    elif type nmap &>/dev/null; then
      nmap -p $nport $nhost
    elif type curl &>/dev/null; then
      if [ $nport -eq 443 ]; then
        curl -ksvIL https://${nhost}:${nport} >/dev/null
      else
        curl -ksvIL http://${nhost}:${nport} >/dev/null
      fi
    else
      if [ $nport -eq 443 ]; then
        wget --no-check-certificate -qS -O- https://${nhost}:${nport} >/dev/null
      else
        wget --no-check-certificate -qS -O- http://${nhost}:${nport} >/dev/null
      fi
    fi
  elif [ "$1" == "px" ]; then
    shift
    if [ "$1" -gt 0 ] 2>/dev/null; then
      export http_proxy=http://127.0.0.1:$1
      export https_proxy=http://127.0.0.1:$1
    elif [[ "$1" =~ "http" ]]; then
      export http_proxy=$1
      export https_proxy=$1
    else
      export http_proxy=http://$1
      export https_proxy=http://$1
    fi
    shift
    execmd "$*"
  elif [ "$1" == "pxs" ] || [ "$1" == "goproxy" ]; then
    shift
    require proxy
    if [ $# -gt 4 ]; then
      proxy $*
    else
      ptype="http"
      proto="tcp"
      pport="38080"
      pargs="$*"
      if [ $# -gt 0 ]; then
        ptype=$1
        shift
        if [ $# -gt 0 ]; then
          pport=$1
          shift
          if [ $# -gt 0 ]; then
            proto=$1
            shift
            if [ $# -gt 0 ]; then
              ptar=$1
              shift
            fi
          fi
        fi
      fi
      if [ "$ptype" == "h" ] || [ "$ptype" == "hp" ] || [ "$ptype" == "help" ]; then
        proxy --help
      elif [ "$ptype" == "http" ] || [ "$ptype" == "https" ]; then
        proxy http -t $proto -p "0.0.0.0:$pport"
      elif [ "$ptype" == "sock" ] || [ "$ptype" == "socks" ] || [ "$ptype" == "socks5" ]; then
        proxy socks -t $proto -p "0.0.0.0:$pport"
      elif [ "$ptype" == "tcp" ] || [ "$ptype" == "udp" ]; then
        proxy $ptype -p ":$pport" -T $proto -P "$ptar"
      else
        proxy $pargs
      fi
    fi
  elif [ "$1" == "it" ] || [ "$1" == "iptable" ] || [ "$1" == "iptables" ]; then
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      iptableshelp
    elif [ "$1" == "help" ]; then
      require iptables
      iptables --help
    else
      require iptables
      iptables $*
    fi
  elif [ "$1" == "ac" ] || [ "$1" == "autocomplete" ]; then
    shift
    if [ "$1" == "b" ] || [ "$1" == "bash" ]; then
      source <(kubectl completion bash)
      echo "source <(kubectl completion bash)" >>~/.bashrc
    elif [ "$1" == "z" ] || [ "$1" == "zsh" ]; then
      source <(kubectl completion zsh)
      echo "source <(kubectl completion zsh)" >>~/.zshrc
      # echo "if [ $commands[kubectl] ]; then source <(kubectl completion zsh); fi" >> ~/.zshrc
    fi
  elif [ "$1" == "jy" ] || [ "$1" == "j2y" ]; then
    require yq
    cat $2 | yq r -P -
  elif [ "$1" == "yj" ] || [ "$1" == "y2j" ]; then
    require yq
    cat $2 | yq r -jP -
  elif [ "$1" == "ym" ] || [ "$1" == "yum" ]; then
    require yum
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ]; then
      yumhelp
    elif [ "$1" == "help" ]; then
      yum --help
    elif [ "$1" == "cr" ] || [ "$1" == "repo" ]; then
      require createrepo
      shift
      if [ -z "$1" ]; then
        createrepo .
      else
        createrepo $1
      fi
    elif [ "$1" == "c" ] || [ "$1" == "cfg" ]; then
      shift
      url="http://127.0.0.1:80/"
      if [ -n "$1" ]; then
        url=$1
      fi
      echo -e "[private]\nname=private\nbaseurl=$url\ngpgcheck=0\nenabled=1\n" >/etc/yum.repos.d/private.repo
      yum clean all && makecache fast
    elif [ "$1" == "d" ] || [ "$1" == "dl" ]; then
      shift
      if type yumdownloader &>/dev/null; then
        yumdownloader --resolve yum install $*
      else
        yum install --downloadonly --downloaddir=./ $*
      fi
    elif [ "$1" == "q" ] || [ "$1" == "rq" ]; then
      require repoquery
      shift
      repoquery $*
    elif [ "$1" == "s" ] || [ "$1" == "sq" ]; then
      shift
      yum search all $*
    elif [ "$1" == "l" ] || [ "$1" == "list" ]; then
      shift
      yum list $* --showduplicates | sort -r
    elif [ "$1" == "i" ] || [ "$1" == "inst" ]; then
      shift
      yum install -y $*
    elif [ "$1" == "r" ] || [ "$1" == "del" ]; then
      shift
      yum remove -y $*
    else
      yum $*
    fi
  elif [ "$1" == "cv" ] || [ "$1" == "convert" ]; then
    shift
    subcmd=$1
    if [ "$1" == "h" ] || [ "$1" == "hp" ] || [ "$1" == "help" ]; then
      converthelp
      exit 0
    fi
    shift
    if [ -z "$1" ]; then
      echo "error: need arguments"
      exit 1
    fi
    files=()
    if [ -f "$1" ]; then
      files[0]="$1"
    elif [ -d "$1" ]; then
      for f in $(ls $1 | sed "s:^:$(pwd)/:"); do
        files+=("$f")
      done
    fi
    for fl in ${files[@]}; do
      fname="${fl%.*}"
      case "$subcmd" in
      "id" | "info" | "ientify")
        if [[ $(fileType "$fl") == "image" ]]; then
          require ientify
          ientify "$fl"
        elif [[ $(fileType "$fl") == "video" ]]; then
          require ffmpeg
          ffmpeg -i "$fl" -hide_banner
        else
          stat "$fl"
        fi
        ;;
      "doc" | "document")
        require pandoc
        pandoc -s $fl -o $fname.$2 ${@:3}
        ;;
      "img" | "image")
        if [[ $(fileType "$fl") == "image" ]]; then
          require convert
          if [ $# -gt 2 ]; then
            convert -density $3 $fl $fname.$2
          else
            convert $fl $fname.$2
          fi
        elif [[ $(fileType "$fl") == "video" ]]; then
          require ffmpeg
          if [ $# -gt 2 ]; then
            ffmpeg -i $fl -r $3 -f image2 $fname-%5d.$2
          else
            ffmpeg -i $fl -r $3 -f image2 $fname-%5d.$2
          fi
        fi
        ;;
      "vdo" | "video")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.$2 ${@:3}
        ;;
      "txt")
        require pandoc
        pandoc -s $fl -o $fname.html ${@:2}
        ;;
      "htm" | "html")
        require pandoc
        pandoc -s $fl -o $fname.html ${@:2}
        ;;
      "md" | "markdown")
        require pandoc
        pandoc -s $fl -o $fname.md ${@:2}
        ;;
      "word" | "docx")
        require pandoc
        pandoc -s $fl -o $fname.docx ${@:2}
        ;;
      "rst")
        require pandoc
        pandoc -s $fl -o $fname.rst ${@:2}
        ;;
      "odt")
        require pandoc
        pandoc -s $fl -o $fname.odt ${@:2}
        ;;
      "rtf")
        require pandoc
        pandoc -s $fl -o $fname.rtf ${@:2}
        ;;
      "json")
        require pandoc
        pandoc -s $fl -o $fname.json ${@:2}
        ;;
      "pdf")
        require pandoc
        pandoc -s $fl -o $fname.pdf ${@:2}
        ;;
      "epub")
        require pandoc
        pandoc -s $fl -o $fname.epub ${@:2}
        ;;
      "ico")
        require convert
        convert -background transparent -define 'icon:auto-resize=16,24,32,64' $fl $fname.ico
        ;;
      "png")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.png
        else
          convert $fl $fname.png
        fi
        ;;
      "bmp")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.bmp
        else
          convert $fl $fname.bmp
        fi
        ;;
      "jpg")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.jpg
        else
          convert $fl $fname.jpg
        fi
        ;;
      "gif")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.gif
        else
          convert $fl $fname.gif
        fi
        ;;
      "tiff")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.tiff
        else
          convert $fl $fname.tiff
        fi
        ;;
      "tif")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.tif
        else
          convert $fl $fname.tif
        fi
        ;;
      "webp")
        require convert
        if [ $# -gt 1 ]; then
          convert -density $2 $fl $fname.webp
        else
          convert $fl $fname.webpp
        fi
        ;;
      "mp4")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.mp4 ${@:2}
        ;;
      "avi")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.avi ${@:2}
        ;;
      "wmv")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.wmv ${@:2}
        ;;
      "rm")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.rm ${@:2}
        ;;
      "rmvb")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.rmvb ${@:2}
        ;;
      "3gp")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.3gp ${@:2}
        ;;
      "mkv")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.mkv ${@:2}
        ;;
      "mov")
        require ffmpeg
        ffmpeg -qscale 0 -i $fl $fname.mov ${@:2}
        ;;
      "an" | "audiono")
        require ffmpeg
        ffmpeg -an -i $fl $fl.${fl##*.} ${@:2}
        ;;
      "vn" | "mp3" | "videono")
        require ffmpeg
        ffmpeg -vn -i $fl $fname.mp3 ${@:2}
        ;;
      "cc" | "concat")
        require ffmpeg
        ffmpeg -f concat -i $fl -c $2
        ;;
      "rs" | "resize")
        if [[ $(fileType "$fl") == "image" ]]; then
          require convert
          convert -resize $2 $fl $fl.${fl##*.}
        elif [[ $(fileType "$fl") == "video" ]]; then
          require ffmpeg
          ffmpeg -i $fl -filter:v scale=$2 -c:a copy $fl.${fl##*.}
        fi
        ;;
      "cut")
        if [[ $(fileType "$fl") == "image" ]]; then
          require convert
          convert -crop $2 $fl $fl.${fl##*.}
        elif [[ $(fileType "$fl") == "video" ]]; then
          require ffmpeg
          if [[ "$3" =~ ":" ]]; then
            ffmpeg -i $fl -ss $2 -to $3 -codec copy $fl.${fl##*.}
          else
            ffmpeg -i $fl -ss $2 -t $3 -codec copy $fl.${fl##*.}
          fi
        elif [[ ${fl##*.} == "pdf" ]]; then
          require gs
          if [ $# -lt 4 ]; then
            echo "error: need arguments"
            exit 1
          fi
          if [[ "$2" == "pdf" ]]; then
            dvc="pdfwrite"
          else
            dvc="$2"
          fi
          if [ -z "$5"]; then
            gs -dNOPAUSE -dQUIET -dBATCH -sDEVICE=$dvc -o %03d.$2 -dFirstPage=$3 -dLastPage=$4 $fl
          else
            gs -dNOPAUSE -dQUIET -dBATCH -sDEVICE=$dvc -o %03d.$2 -dFirstPage=$3 -dLastPage=$4 -r$5 $fl
          fi
        fi
        ;;
      "ql" | "sc" | "scale" | "quality")
        if [[ $(fileType "$fl") == "image" ]]; then
          require convert
          convert quality $2 $fl $fl.${fl##*.}
        elif [[ $(fileType "$fl") == "video" ]]; then
          require ffmpeg
          ffmpeg -i $fl -vcodec libx265 -crf $2 $fl.${fl##*.}
        elif [[ $(fileType "$fl") == "audio" ]]; then
          require ffmpeg
          ffmpeg -i $fl -ab $2 $fl.${fl##*.}
        fi
        ;;
      "rt" | "rotate")
        require convert
        convert -rotate $2 $fl $fl.${fl##*.}
        ;;
      "fi" | "flip")
        require convert
        convert -flip $fl $fl.${fl##*.}
        ;;
      "fo" | "flop")
        require convert
        convert -flop $fl $fl.${fl##*.}
        ;;
      "br" | "blur")
        require convert
        convert -blur $2 $fl $fl.${fl##*.}
        ;;
      "wb" | "gray")
        require convert
        convert -monochrome $fl $l.${fl##*.}
        ;;
      "ng" | "negate")
        require convert
        convert -negate $fl $fl.${fl##*.}
        ;;
      "ns" | "noise")
        require convert
        convert -noise $2 $fl $fl.${fl##*.}
        ;;
      "pt" | "paint")
        require convert
        convert -paint $2 $fl $fl.${fl##*.}
        ;;
      "cc" | "charcoal")
        require convert
        convert -charcoal $2 $fl $fl.${fl##*.}
        ;;
      "sp" | "spread")
        require convert
        convert -spread $2 $fl $fl.${fl##*.}
        ;;
      "sw" | "swirl")
        require convert
        convert -swirl $2 $fl $fl.${fl##*.}
        ;;
      "ri" | "raise")
        require convert
        convert -raise $2 $fl $fl.${fl##*.}
        ;;
      "bd" | "border")
        require convert
        convert -border $2 -bordercolor "$3" $fl $fl.${fl##*.}
        ;;
      "wm" | "watermark")
        require convert
        wtext="text 0,0 \"$2\""
        wsize="54"
        wfill="rgba(221, 34, 17, 0.25)"
        wfont=""
        wloc="center"

        if [ $# -gt 2 ]; then
          wsize="$3"
        fi
        if [ $# -gt 3 ]; then
          wfill="$4"
        fi
        if [ $# -gt 4 ]; then
          wfont="-font $5"
        fi
        if [ $# -gt 5 ]; then
          wloc="$6"
        fi
        convert -draw "$wtext" -fill "$wfill" -pointsize $wsize $wfont -gravity $wloc $fl $fl.${fl##*.}
      esac
    done
  elif [ "$1" == "n" ] || [ "$1" == "net" ]; then
    shift
    subcmd=$1
    shift
    case "$subcmd" in
    "h" | "hp" | "help")
      nethelp
      ;;
    "arp")
      require arp
      if [ -z "$1" ]; then
        arp -a
      else
        arp -a -i $1
      fi
      ;;
    "pi")
      if type nmap &>/dev/null; then
        sudo nmap -sP --disable-arp-ping $1
      elif type fping &>/dev/null; then
        fping -Ae $*
      else
        ping $*
      fi
      ;;
    "pp")
      pping "$@"
      ;;
    "br")
      require brctl
      brctl $*
      ;;
    "brs")
      require brctl
      brctl show
      ;;
    "brl")
      require bridge
      bridge link show -d
      ;;
    "brv")
      require bridge
      bridge vlan show -d
      ;;
    "brf"|"ipf")
      require bridge
      bridge fdb show -d
      ;;
    "brm")
      require bridge
      bridge mdb show -d
      ;;
    "ip")
      require ip
      ip $*
      ;;
    "ipn")
      require ip
      ip n
      ;;
    "ipr")
      require ip
      ip r
      ;;
    "ipa")
      require ip jq
      getip "ipa" "$1"
      ;;
    "ipp")
      require ip jq
      getip "ipp" "$1"
      ;;
    "ips")
      require ip
      itfs=$(ip -j a | jq -rM '.[].ifname' | grep "$1")
      itfs=($itfs)
      if [ ${#itfs[@]} -eq 1 ]; then
        titf="${itfs[0]}"
      else
        echo "====== More than one net interface ======"
        for ((i = 0; i < ${#itfs[@]}; i++)); do
          echo "$i: ${itfs[$i]}"
        done
        read -p "====== select one with number[0]: " iidx
        if [ -z "$iidx" ]; then
          iidx=0
        fi
        titf=${itfs[$iidx]}
      fi
      ip -s a show dev $titf
      ;;
    "tr")
      if ! type mtr &>/dev/null; then
        traceroute $*
      else
        if [ -z "$1" ]; then
          mtr
        else
          mtr $*
        fi
      fi
      ;;
    "ss")
      if ! type ss &>/dev/null; then
        if [ -z "$1" ]; then
          netstat -vatunlp
        else
          netstat $*
        fi
      else
        if [ -z "$1" ]; then
          ss -asntup
        else
          ss $*
        fi
      fi
      ;;
    "nl")
      if type host &>/dev/null; then
        host $*
      elif type nslookup &>/dev/null; then
        nslookup $*
      else
        dig $*
      fi
      ;;
    "nm")
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        nmaphelp
      elif [ $1 == "help" ]; then
        require nmap
        nmap --help
      else
        require nmap
        if [ $# -eq 1 ]; then
          sudo nmap -sS -P0 -sV -O $1
        else
          nmap $*
        fi
      fi
      ;;
    "td")
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        tcpdumphelp
      elif [ $1 == "help" ]; then
        require tcpdump
        tcpdump --help
      else
        require tcpdump
        tcpdump $*
      fi
      ;;
    "ts")
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        tsharkhelp
      elif [ $1 == "help" ]; then
        require tshark
        tshark --help
      else
        require tshark
        tshark $*
      fi
      ;;
    "it")
      if [ $1 == "h" ] || [ $1 == "hp" ]; then
        iptableshelp
      elif [ $1 == "help" ]; then
        require iptables
        iptables --help
      else
        require iptables
        iptables $*
      fi
      ;;
    "ps")
      if [ $# -eq 1 ]; then
        nhost="127.0.0.1"
        nport=$1
      elif [ $# -gt 1 ]; then
        nhost=$1
        nport=$2
      else
        echo "error: need arguments"
      fi
      if type nc &>/dev/null; then
        nc -zv $nhost $nport
      elif type telnet &>/dev/null; then
        echo -e '\035\nquit' | telnet $nhost $nport
      elif type nmap &>/dev/null; then
        nmap -p $nport $nhost
      elif type curl &>/dev/null; then
        if [ $nport -eq 443 ]; then
          curl -ksvIL https://${nhost}:${nport} >/dev/null
        else
          curl -ksvIL http://${nhost}:${nport} >/dev/null
        fi
      else
        if [ $nport -eq 443 ]; then
          wget --no-check-certificate -qS -O- https://${nhost}:${nport} >/dev/null
        else
          wget --no-check-certificate -qS -O- https://${nhost}:${nport} >/dev/null
        fi
      fi
      ;;
    "pc")
      require iptables
      if [ $# -lt 1 ]; then
        echo "error: need arguments"
      fi
      if [ "$1" == "open" ] || [ "$1" == "accept" ]; then
        paction="ACCEPT"
      elif [ "$1" == "close" ] || [ "$1" == "drop" ]; then
        paction="DROP"
      else
        paction="DROP"
      fi
      shift
      for pport in $*; do
        sudo /sbin/iptables -I INPUT -p tcp --dport $pport -j $paction
      done
      ;;
    "pxs")
      require proxy
      if [ $# -gt 4 ]; then
        proxy $*
      else
        ptype="http"
        proto="tcp"
        pport="38080"
        pargs="$*"
        if [ $# -gt 0 ]; then
          ptype=$1
          shift
          if [ $# -gt 0 ]; then
            pport=$1
            shift
            if [ $# -gt 0 ]; then
              proto=$1
              shift
              if [ $# -gt 0 ]; then
                ptar=$1
                shift
              fi
            fi
          fi
        fi
        if [ "$ptype" == "h" ] || [ "$ptype" == "hp" ] || [ "$ptype" == "help" ]; then
          proxy --help
        elif [ "$ptype" == "http" ] || [ "$ptype" == "https" ]; then
          proxy http -t $proto -p "0.0.0.0:$pport"
        elif [ "$ptype" == "sock" ] || [ "$ptype" == "socks" ] || [ "$ptype" == "socks5" ]; then
          proxy socks -t $proto -p "0.0.0.0:$pport"
        elif [ "$ptype" == "tcp" ] || [ "$ptype" == "udp" ]; then
          proxy $ptype -p ":$pport" -T $proto -P "$ptar"
        else
          proxy $pargs
        fi
      fi
      ;;
    esac
  elif [ "$1" == "ct" ] || [ "$1" == "ssl" ] || [ "$1" == "cred" ]; then
    require openssl
    shift
    if [ $# -ge 1 ]; then
      subcmd="$1"
      shift
      case "$subcmd" in
      "h" | "hp" | "help")
        sslhelp
        exit 0
        ;;
      "gen" | "generate")
        genssl "$*"
        ;;
      "out" | "show")
        if [ $# -eq 0 ]; then
          openssl x509 -noout -text -in *
        elif [ $# -eq 1 ]; then
          openssl x509 -noout -text -in $1
        elif [ $# -eq 2 ]; then
          openssl x509 -noout -$2 -in $1
        fi
        ;;
      "mat" | "match")
        if [ $# -eq 2 ]; then
          key=$(openssl rsa --noout --modulus --in $1 | openssl md5)
          cert=$(openssl x509 --noout --modulus --in $2 | openssl md5)
          if [ "$key" == "$cert" ]; then
            echo "true"
          else
            echo "false"
          fi
        else
          echo "error: need arguments"
        fi
        ;;
      "ver" | "verify")
        if [ $# -eq 2 ]; then
          openssl verify -verbose -CAfile $1 $2
        elif [ $# -eq 3 ]; then
          openssl verify -verbose -CAfile $1 -untrusted $2 $3
        else
          echo "error: need arguments"
        fi
        ;;
      "get" | "fetch")
        if [ $# -eq 1 ]; then
          openssl s_client -showcerts -verify 32 -connect $1 | openssl x509 -text
        else
          echo "error: need arguments"
        fi
        ;;
      "sver" | "sverify")
        if [ $# -eq 1 ]; then
          domain=${1##*/}
          domain=${domain%:*}
          openssl s_client -showcerts -verify 32 -servername $domain -connect $1
        elif [ $# -eq 2 ]; then
          openssl s_client -showcerts -verify 32 -servername $2 -connect $1
        else
          echo "error: need arguments"
        fi
        ;;
      esac
    fi
  elif [ "$1" == "d" ] || [ "$1" == "docker" ]; then
    require docker
    shift
    docker $*
  elif [ "$1" == "dc" ] || [ "$1" == "dkc" ] || [ "$1" == "docker-compose" ]; then
    require docker-compose
    shift
    docker-compose $*
  elif [ "$1" == "dcu" ]; then
    require docker-compose
    shift
    docker-compose up $*
  elif [ "$1" == "dcd" ]; then
    require docker-compose
    shift
    docker-compose down $*
  elif [ "$1" == "k" ] || [ "$1" == "kube" ] || [ "$1" == "kubectl" ]; then
    require kubectl
    shift
    kubectl $*
  elif [ "$1" == "ghp" ] || [ "$1" == "ghelp" ]; then
    require go
    shift
    go help $*
  elif [ "$1" == "gweb" ]; then
    xdg-open https://golang.org/cmd/go/
  elif [ "$1" == "dhp" ] || [ "$1" == "dhelp" ]; then
    require docker
    shift
    docker $* --help
  elif [ "$1" == "dweb" ]; then
    xdg-open https://docs.docker.com/engine/reference/commandline/docker/
  elif [ "$1" == "khp" ] || [ "$1" == "khelp" ]; then
    require kubectl
    shift
    kubectl $* --help
  elif [ "$1" == "kweb" ]; then
    xdg-open https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands
  elif [ "$1" == "dq" ] || [ "$1" == "dsearch" ]; then
    require docker
    shift
    docker search $*
  elif [ "$1" == "dreg" ] || [ "$1" == "dregistry" ]; then
    require docker
    shift
    # docker run ‐d ‐p 5000:5000 ‐‐restart=always ‐‐name registry ‐v /usr/docker/registry:/var/lib/registry registry:2
    docker run -d --restart always --name registry -p 5000:5000 registry:2
  elif [ "$1" == "dr" ] || [ "$1" == "drun" ]; then
    require docker
    shift
    docker run $*
  elif [ "$1" == "drt" ] || [ "$1" == "dtmp" ]; then
    require docker
    shift
    docker run -it --rm $*
  elif [ "$1" == "db" ] || [ "$1" == "dbd" ]; then
    require docker
    shift
    docker build $*
  elif [ "$1" == "sp" ] || [ "$1" == "spl" ] || [ "$1" == "sample" ]; then
    shift
    skind="pod"
    if [ $# -gt 0 ]; then
      skind=$(aliasKind $1)
    fi
    printSample "$skind"
  elif [ "$1" == "ans" ]; then
    shift
    local text
    local host=$1
    local offset
    host=$(echo $host|sed 's/\./\\./g')
    #IFS=$'\r\n' read -d '' -r -a text < $2
    if [ $# == 1 ]; then
      text=$(cat $2)
    else
      if [ -f $2 ]; then
        text=$(cat $2)
      else
        offset=$2
        text=$(cat $3)
      fi
    fi
    if [ -n "$offset" ] && type jq >/dev/null 2>&1; then
      echo "$text" | \grep -Pzo "\[?$host\]?.* => {\n(.*\n)*?}\n?"|sed "s/^\S.* => {/{/g" | jq -rsM . | jq -rM .[$offset]
    else
      echo "$text" | \grep -Pzo "\[?$host\]?.* => {\n(.*\n)*?}\n?"|sed "s/^\S.* => {/{/g"
    fi
  elif [ "$1" == "id" ] || [ "$1" == "uuid" ] || [ "$1" == "guid" ]; then
    require cat tr fold head
    if [ "$1" == "uuid" ]; then
      shift
      if [ "$1" == "h" ] || [ "$1" == "hp" ] || [ "$1" == "help" ]; then
        idhelp
      elif [ "$1" == "-" ]; then
        a=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 8 | head -n 1)
        b=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 4 | head -n 1)
        c=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 4 | head -n 1)
        d=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 4 | head -n 1)
        e=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 12 | head -n 1)
        echo "$a-$b-$c-$d-$e"
      else
        cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1
      fi
    elif [ "$1" == "guid" ]; then
      shift
      if [ "$1" == "h" ] || [ "$1" == "hp" ] || [ "$1" == "help" ]; then
        idhelp
      elif [ "$1" == "-" ]; then
        a=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)
        b=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 4 | head -n 1)
        c=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 4 | head -n 1)
        d=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 4 | head -n 1)
        e=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 12 | head -n 1)
        echo "$a-$b-$c-$d-$e"
      else
        cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1
      fi
    else
      shift
      idtype="$1"
      if [ -z "$2" ]; then
        idlen=1
      else
        idlen=$2
      fi
      if [ "$idtype" == "h" ] || [ "$idtype" == "hp" ] || [ "$idtype" == "help" ]; then
        idhelp
      elif [ "$idtype" == "n" ]; then
        cat /dev/urandom | tr -dc '0-9' | fold -w 256 | head -n 1 | head --bytes $idlen
      elif [ "$idtype" == "l" ]; then
        cat /dev/urandom | tr -dc 'a-z' | fold -w 256 | head -n 1 | head --bytes $idlen
      elif [ "$idtype" == "u" ]; then
        cat /dev/urandom | tr -dc 'A-Z' | fold -w 256 | head -n 1 | head --bytes $idlen
      elif [ "$idtype" == "c" ]; then
        cat /dev/urandom | tr -dc 'a-zA-Z' | fold -w 256 | head -n 1 | head --bytes $idlen
      elif [ "$idtype" == "nl" ]; then
        cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 256 | head -n 1 | head --bytes $idlen
      elif [ "$idtype" == "nu" ]; then
        cat /dev/urandom | tr -dc 'A-Z0-9' | fold -w 256 | head -n 1 | head --bytes $idlen
      elif [ "$idtype" == "a" ] || [ "$idtype" == "nc" ]; then
        cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 256 | head -n 1 | head --bytes $idlen
      else
        cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 256 | head -n 1 | head --bytes $idtype
      fi
    fi
  elif [ "$1" == "tm" ] || [ "$1" == "time" ]; then
    shift
    if [ "$1" == "h" ] || [ "$1" == "hp" ] || [ "$1" == "help" ]; then
      timehelp
    elif [ "$1" == "l" ] || [ "$1" == "local" ]; then
      date
      date +"%Y-%m-%d %H:%M:%S"
    elif [ "$1" == "u" ] || [ "$1" == "utc" ]; then
      date -u
      date -u +"%Y-%m-%d %H:%M:%S"
    elif [ "$1" == "e" ] || [ "$1" == "en" ]; then
      env LANG=en_US.UTF-8 date
    elif [ "$1" == "d" ] || [ "$1" == "date" ]; then
      date +"%Y-%m-%d"
    elif [ "$1" == "t" ] || [ "$1" == "time" ]; then
      date +"%H:%M:%S"
    elif [ "$1" == "w" ] || [ "$1" == "week" ]; then
      env LANG=en_US.UTF-8 date +%A
    elif [ "$1" == "std" ] || [ "$1" == "standard" ]; then
      date +%Y%m%d%H%M%S
    elif [ "$1" == "fmt" ] || [ "$1" == "format" ]; then
      date +"%Y-%m-%d %H:%M:%S"
    elif [ "$1" == "ts" ] || [ "$1" == "timestamp" ]; then
      date +%s
    elif [ "$1" == "tsn" ] || [ "$1" == "tsns" ] || [ "$1" == "timestampns" ]; then
      date +%s%N
    elif [ "$1" == "tsm" ] || [ "$1" == "tsms" ] || [ "$1" == "timestampms" ]; then
      echo $(($(date +%s%N) / 1000000))
    elif [ "$1" == "cv" ]; then
      shift
      if (($1)) 2>/dev/null; then
        date -d @$1 +'%Y-%m-%d %H:%M:%S'
      else
        date -d "$1" +'%s'
        date -d "$1" +'%Y-%m-%d %H:%M:%S'
      fi
    else
      date $*
    fi
  else
    while [ $# -gt 0 ] && [[ "$1" != "--" ]]; do
      while getopts "a:b:c:d:f:i:k:l:m:n:o:p:s:t:u:w:hgjqrvy" opt; do
        case $opt in
        a)
          since="--since $OPTARG"
          ;;
        b)
          amount="--tail $OPTARG"
          ;;
        c)
          context="--context $OPTARG"
          ;;
        d)
          savedir="$OPTARG"
          ;;
        f)
          cfile="$OPTARG"
          kc="--kubeconfig $cfile"
          ;;
        g)
          list=1
          ;;
        h)
          host="$OPTARG"
          ;;
        i)
          idx=$OPTARG
          ;;
        j)
          localrun=1
          ;;
        k)
          kind=$(aliasKind $OPTARG)
          ;;
        l)
          selector="--selector=$OPTARG"
          ;;
        m)
          image=$OPTARG
          ;;
        n)
          namespace=$OPTARG
          ;;
        o)
          output="--output $OPTARG"
          ;;
        p)
          port=$OPTARG
          ;;
        q)
          neat=1
          ;;
        r)
          chroot="-c 'chroot /proc/1/root/'"
          ;;
        s)
          passwd=$OPTARG
          ;;
        t)
          timeout=$OPTARG
          ;;
        u)
          user=$OPTARG
          ;;
        v)
          vol="-v /var/run/docker.sock:/var/run/docker.sock"
          ;;
        w)
          kwd=$OPTARG
          ;;
        y)
          dryrun="--dry-run"
          ;;
        h)
          usage
          exit 0
          ;;
        \?)
          echo "Invalid option: -$OPTARG" >&2
          usage
          exit 1
          ;;
        esac
      done

      shift $((OPTIND - 1))

      while [ $# -gt 0 ] && (! [[ "$1" =~ ^- ]] || [[ "$1" =~ ^-- ]]); do
        mandatory=("${mandatory[@]}" "$1")
        shift
        OPTIND=1 # reset OPTIND
      done
    done

    if [ "$1" == "--" ]; then
      shift
      mandatory=("${mandatory[@]}" "$@")
    fi

    if ! [[ "${mandatory[0]}" =~ ^- ]]; then
      subcmd=${mandatory[0]}
      mandatory=("${mandatory[@]:1}")
    fi

    if [ -z "$subcmd" ]; then
      echo "need sub command"
      usage simple
      exit 1
    fi

    if [ -z "$namespace" ]; then
      ns="--all-namespaces"
    else
      ns="-n $namespace"
    fi

    if [ "$subcmd" == "hp" ]; then
      usage simple
      exit 0
    elif [ "$subcmd" == "help" ]; then
      usage
      exit 0
    elif [ "$subcmd" == "c" ] || [ "$subcmd" == "cmd" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        cmd=${mandatory[0]}
        if [ ${#mandatory[@]} -eq 1 ]; then
          execmd "$cmd"
        else
          for ip in ${mandatory[@]:1}; do
            if [ $localrun -eq 0 ]; then
              execmd "$cmd" $ip
            else
              lexecmd "$cmd" $ip
            fi
          done
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "bat" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        mode=${mandatory[0]}
        if [ -f "$cfile" ]; then
          IFS=$'\r\n' read -d '' -r -a hosts < $cfile
          args="${mandatory[@]:1}"
        else
          if [ ${#mandatory[@]} -le 1 ]; then
            batch "help" "help"
            exit 1
          fi
          hosts=${mandatory[1]}
          args="${mandatory[@]:2}"
        fi
        for ip in ${hosts[*]}; do
          batch "$mode" "$ip" "$args"
        done
      else
        batch "help" "help"
        exit 1
      fi
    elif [ "$subcmd" == "scp" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        cppaths=${mandatory[0]}
        if [ ${#mandatory[@]} -eq 1 ]; then
          remotecp "$cppaths"
        else
          for ip in ${mandatory[@]:1}; do
            remotecp "$cppaths" $ip
          done
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "cu" ] || [ "$subcmd" == "au" ] || [ "$subcmd" == "createuser" ] || [ "$subcmd" == "adduser" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        iuname=${mandatory[0]%/*}
        ipasswd=${mandatory[0]##*/}
        cmd="adduser $iuname;echo $ipasswd | passwd $iuname --stdin"
        if [ ${#mandatory[@]} -gt 1 ]; then
          for ip in ${mandatory[@]:1}; do
            execmd "$cmd" $ip
          done
        else
          execmd "$cmd"
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "opt" ] || [ "$subcmd" == "optimize" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        if type kude &>/dev/null; then
          cppaths="$(which kude):/tmp/"
        else
          cppaths="./kude:/tmp/"
        fi
        for ip in ${mandatory[@]}; do
          remotecp "$cppaths" $ip
          execmd "bash /tmp/kude opt; rm -rf /tmp/kude" $ip
        done
      else
        optimize
      fi
    elif [ "$subcmd" == "gs" ]; then
      require git
      cmsg="update"
      if [ ${#mandatory[@]} -gt 0 ]; then
        cmsg=${mandatory[*]}
      fi
      git add -A .
      git commit -m "$cmsg"
      git push
    elif [ "$subcmd" == "gl" ]; then
      require git
      git pull
    elif [ "$subcmd" == "gg" ]; then
      require git
      git log --oneline --graph --decorate
    elif [ "$subcmd" == "pq" ] || [ "$subcmd" == "promq" ]; then
      if [ ${#mandatory[@]} -gt 0 ]; then
        sscmd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$host" ]; then
        url=$host
      elif [ ${#mandatory[@]} -gt 0 ]; then
        if [[ "${mandatory[0]}" =~ "." ]] || [[ "${mandatory[0]}" == "localhost" ]]; then
          url="${mandatory[0]}"
          mandatory=("${mandatory[@]:1}")
        fi
      else
        url="127.0.0.1"
      fi
      if [ -n "$port" ]; then
        url=$url:$port
      fi
      require curl jq
      case "$sscmd" in
      "h" | "hp" | "help")
        promqhelp
        exit 0
        ;;
      "i" | "m" | "md" | "info" | "metadata")
        if [ ${#mandatory[@]} -eq 0 ]; then
          if [ ${#mandatory[@]} -eq 0 ] && [ $(curl -o /dev/null -s -w "%{http_code}\n" http://$url/api/v1/metadata) -lt 300 ]; then
            curl -Gks http://$url/api/v1/metadata | jq
          else
            curl -Gks http://$url/api/v1/targets/metadata | jq
          fi
        else
          mkwd="${mandatory[0]}"
          mandatory=("${mandatory[@]:1}")
          if [ ${#mandatory[@]} -eq 0 ] && [ $(curl -o /dev/null -s -w "%{http_code}\n" http://$url/api/v1/metadata) -lt 300 ]; then
            curl -Gks http://$url/api/v1/metadata | jq -rM ".data|with_entries(select(.key|contains(\"$mkwd\")))"
          else
            mts=$(curl -Gks http://$url/api/v1/label/__name__/values | jq -rM ".data[]|select(.|contains(\"$mkwd\"))")
            mts=($mts)
            if [ ${#mts[@]} -eq 0 ]; then
              exit 0
            elif [ ${#mts[@]} -eq 1 ]; then
              metric="${mts[0]}"
            else
              echo "====== More than one metric ======"
              for ((i = 0; i < ${#mts[@]}; i++)); do
                echo "$i: ${mts[$i]}"
              done
              read -p "====== select one with number[0]: " midx
              if [ -z "$midx" ]; then
                midx=0
              fi
              metric=${mts[$midx]}
            fi
            if [ ${#mandatory[@]} -eq 0 ]; then
              tgl="instance"
              insts=$(curl -Gks http://$url/api/v1/series --data-urlencode "match[]=$metric" | jq -rM ".data[]|.instance" | sort | uniq)
              insts=($insts)
              if [ ${#insts[@]} -eq 0 ]; then
                exit 0
              elif [ ${#insts[@]} -eq 1 ]; then
                tgv="${insts[0]}"
              else
                echo "====== More than one instance ======"
                for ((i = 0; i < ${#insts[@]}; i++)); do
                  echo "$i: ${insts[$i]}"
                done
                read -p "====== select one with number[0]: " iidx
                if [ -z "$iidx" ]; then
                  iidx=0
                fi
                tgv=${insts[$iidx]}
              fi
            else
              tgl=${mandatory[0]%=*}
              tgv=${mandatory[0]##*=}
              if [ "$tgl" == "$tgv" ]; then
                tgl="instance"
              fi
            fi
            curl -Gks http://$url/api/v1/targets/metadata --data-urlencode "match_target={$tgl=~\".*$tgv.*\"}" | jq -rM ".data[] | select(.metric|contains(\"$metric\"))"
          fi
        fi
        ;;
      "s" | "inst" | "series" | "instance")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "error: need arguments"
          exit 1
        fi
        metric="${mandatory[0]}"
        curl -Gks http://$url/api/v1/series --data-urlencode "match[]=$metric" | jq
        ;;
      "l" | "v" | "lv" | "lb" | "label" | "value")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/labels | jq
        else
          curl -Gks http://$url/api/v1/label/${mandatory[0]}/values | jq
        fi
        ;;
      "t" | "tg" | "target")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/targets | jq
        else
          curl -Gks http://$url/api/v1/targets?state=${mandatory[0]} | jq
        fi
        ;;
      "r" | "rl" | "rule")
        if [ ${#mandatory[@]} -eq 0 ]; then
          curl -Gks http://$url/api/v1/rules | jq
        else
          curl -Gks http://$url/api/v1/rules?type=${mandatory[0]} | jq
        fi
        ;;
      "a" | "al" | "alert")
        curl -Gks http://$url/api/v1/alerts | jq
        ;;
      "am" | "alertmanager")
        curl -Gks http://$url/api/v1/alertmanagers | jq
        ;;
      "v" | "status")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "========================== config =========================="
          curl -Gks http://$url/api/v1/status/config
          echo "========================== flags ==========================="
          curl -Gks http://$url/api/v1/status/flags
          echo "======================== runtimeinfo ======================="
          curl -Gks http://$url/api/v1/status/runtimeinfo
          echo "========================= buildinfo ========================"
          curl -Gks http://$url/api/v1/status/buildinfo
          echo "=========================== tsdb ==========================="
          curl -Gks http://$url/api/v1/status/tsdb
        else
          curl -Gks http://$url/api/v1/status/${mandatory[0]} | jq
        fi
        ;;
      "q" | "query")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "error: need arguments"
          exit 1
        fi
        query="${mandatory[0]}"
        if [[ ! "$query" =~ ^query=.* ]]; then
          query="query=$query"
        fi
        if [ ${#mandatory[@]} -gt 1 ]; then
          ptime="--data-urlencode \"time=${mandatory[1]}\""
          if [ ${#mandatory[@]} -gt 2 ]; then
            ptimeout="--data-urlencode \"timeout=${mandatory[2]}\""
          fi
        fi
        curl -Gks http://$url/api/v1/query --data-urlencode "$query" $ptime $ptimeout | jq
        ;;
      "qr" | "rq" | "query_range")
        if [ ${#mandatory[@]} -eq 0 ]; then
          echo "error: need arguments"
          exit 1
        fi
        query="${mandatory[0]}"
        if [[ ! "$query" =~ ^query=.* ]]; then
          query="query=$query"
        fi
        if [ ${#mandatory[@]} -gt 1 ]; then
          stime="--data-urlencode \"start=${mandatory[1]}\""
          if [ ${#mandatory[@]} -gt 2 ]; then
            etime="--data-urlencode \"end=${mandatory[2]}\""
            if [ ${#mandatory[@]} -gt 3 ]; then
              step="--data-urlencode \"step=${mandatory[3]}\""
              if [ ${#mandatory[@]} -gt 4 ]; then
                ptimeout="--data-urlencode \"timeout=${mandatory[2]}\""
              fi
            fi
          fi
        fi
        curl -Gks http://$url/api/v1/query_range --data-urlencode "$query" $stime $etime $step $ptimeout | jq
        ;;
      *)
        curl -Gks ${mandatory[*]} | jq
        ;;
      esac
    elif [ "$subcmd" == "dps" ] || [ "$subcmd" == "dlist" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker ps -a | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker ps -a | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker ps -a"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dm" ] || [ "$subcmd" == "dim" ] || [ "$subcmd" == "dimg" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker image ls | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker image ls | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker image ls"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dn" ] || [ "$subcmd" == "dnet" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker network ls | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker network ls | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker network ls"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dv" ] || [ "$subcmd" == "dvol" ]; then
      if [ -n "$kwd" ]; then
        cmd="docker volume ls | grep $kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        cmd="docker volume ls | grep ${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      else
        cmd="docker volume ls"
      fi
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dcc" ]; then
      cmd="docker rm $(docker ps -qaf 'status=exited')"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dic" ]; then
      cmd="docker image prune -a"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dvc" ]; then
      cmd="docker volume prune"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dnc" ]; then
      cmd="docker network prune"
      if [ ${#mandatory[@]} -eq 0 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "ds" ] || [ "$subcmd" == "dput" ] || [ "$subcmd" == "dpush" ]; then
      require docker
      if [ ${#mandatory[@]} -gt 0 ]; then
        imgname=${mandatory[0]%:*}
        imgtag=${mandatory[0]##*:}
        if [ $imgname == $imgtag ]; then
          imgtag=""
        fi
        #       if [ -z $imgtag ] || [ $imgtag == "" ]; then
        #         imgtag="latest"
        #       fi
        #     if [ $(docker images|grep $imgname|awk '{print $2}'|grep $imgtag|wc -l) -eq 0 ]; then
        if [ -z "$imgtag" ] && [ $(docker images | grep $imgname | wc -l) -gt 1 ]; then
          #         docker pull $imgname:$imgtag
          echo "====== More than one image ======"
          imgs=$(docker images | grep $imgname | awk '{print $1":"$2}')
          SIFS=$IFS
          IFS=$'\n'
          imgs=($imgs)
          IFS=$SIFS
          for ((i = 0; i < ${#imgs[@]}; i++)); do
            echo "$i: ${imgs[$i]}"
          done
          imgtag="latest"
          echo "-1: pull $imgname:$imgtag"
          read -p "====== select one with number[0]: " iidx
          if [ -z "$iidx" ]; then
            iidx=0
          fi
          if [ $iidx -eq -1 ]; then
            docker pull $imgname:$imgtag
            irs=$imgname:$imgtag
          else
            irs=${imgs[$iidx]}
          fi
          llib=${irs%/*}
          limg=${irs##*/}
        elif [ $(docker images | grep $imgname | wc -l) -eq 0 ]; then
          pimg=$imgname:latest
          docker pull $pimg
          llib=${pimg%/*}
          limg=${pimg##*/}
        else
          if [ -z "$imgtag" ]; then
            imgtag="latest"
          fi
          pimg=$imgname:$imgtag
          llib=${pimg%/*}
          limg=${pimg##*/}
        fi

        if [ $llib == $limg ]; then
          llib=""
        fi

        if [ ${#mandatory[@]} -gt 1 ]; then
          rrepo=${mandatory[1]%%/*}
          rlib=${mandatory[1]#*/}
        fi

        rimg=${rlib#*/}
        rlib=${rlib%%/*}

        if [ "$rimg" == "$rlib" ]; then
          rimg=""
        fi

        if [ "$rlib" == "" ] || [ "$rlib" == "$rrepo" ]; then
          if [[ "$rrepo" =~ "." ]]; then
            rlib="library"
          else
            rlib=$rrepo
            rrepo="docker.io"
          fi
        fi

        if [ -z "$rlib" ]; then
          if [ -n "$llib" ]; then
            rlib=$llib
          else
            rlib="library"
          fi
        fi
        if [ -z "$rrepo" ]; then
          rrepo="docker.io"
        fi

        if [ -z "$llib" ]; then
          simg=$limg
        else
          simg=$llib/$limg
        fi

        if [ "$rimg" != "$limg" ] && [ -n "$rimg" ] && [ "$rimg" != "" ]; then
          limg=$rimg
        fi

        docker tag $simg $rrepo/$rlib/$limg
        docker push $rrepo/$rlib/$limg
        if [ "$rrepo" != "docker.io" ]; then
          docker rmi -f $rrepo/$rlib/$limg
        fi
      else
        echo "error: need arguments"
      fi
    elif [ "$subcmd" == "dl" ] || [ "$subcmd" == "dget" ] || [ "$subcmd" == "dpull" ]; then
      cmd="docker pull ${mandatory[0]}"
      if [ ${#mandatory[@]} -eq 1 ]; then
        require docker
        execmd "$cmd"
      else
        for ip in ${mandatory[@]:1}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dd" ] || [ "$subcmd" == "drm" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker rm -f $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          echo "-1: ALL"
          read -p "====== select one or more with number[0]: " dcidx
          if [ -z "$dcidx" ]; then
            dcidx=0
          fi
          for item in ${dcidx[@]}; do
            if [ $item -eq -1 ]; then
              docker rm -f $(docker ps -a | grep "$fkwd" | awk '{print $1}')
            else
              docker rm -f $(echo ${conts[$item]} | awk '{print $1}')
            fi
          done
        fi
      else
        cmd="docker rm -f $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dcp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
        if [ -z "$args" ] && [ ${#mandatory[@]} -gt 0 ]; then
          args="${mandatory[*]}"
        else
          echo "error: need arguments"
          exit 1
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          tcid=$(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z "$dcidx" ]; then
            dcidx=0
          fi
          tcid=$(echo ${conts[$dcidx]} | awk '{print $1}')
        fi
        prearg=$(echo "$args" | awk -F ':' '{print $1}')
        sufarg=$(echo "$args" | awk -F ':' '{print $2}')
        if [ "$prearg" == "" ]; then
          prearg="$tcid:"$prearg
        else
          sufarg="$tcid:"$sufarg
        fi
        docker cp $prearg$sufarg
      fi
    elif [ "$subcmd" == "dx" ] || [ "$subcmd" == "ddbg" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
        if ([ -z "$image" ] || [ "$image" == "xo" ]) && [ ${#mandatory[@]} -gt 0 ]; then
          image="${mandatory[0]}"
        elif [ -z "$image" ]; then
          image="busybox"
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          tcid=$(docker ps -a | grep "$fkwd" | awk '{print $1}')
          docker run -it --network=container:$tcid --pid=container:$tcid --ipc=container:$tcid $image
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z "$dcidx" ]; then
            dcidx=0
          fi
          tcid=$(echo ${conts[$dcidx]} | awk '{print $1}')
          docker run -it --network=container:$tcid --pid=container:$tcid --ipc=container:$tcid $image
        fi
      fi
    elif [ "$subcmd" == "de" ] || [ "$subcmd" == "dexe" ] || [ "$subcmd" == "dexec" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
        if [ ${#mandatory[@]} -gt 0 ]; then
          dcmd="${mandatory[*]}"
        else
          dcmd="sh"
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker exec $(docker ps -a | grep "$fkwd" | awk '{print $1}') $dcmd
        else
          echo "====== More than one container ======"
          conts=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z "$dcidx" ]; then
            dcidx=0
          fi
          docker exec $(echo ${conts[$dcidx]} | awk '{print $1}') $dcmd
        fi
      fi
    elif [ "$subcmd" == "dpt" ] || [ "$subcmd" == "dpst" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
      else
        echo "error: need arguments"
        exit 1
      fi
      if [ -n "$fkwd" ]; then
        require docker
        if [ $(docker ps | grep "$fkwd" | wc -l) -lt 2 ]; then
           pid=$(docker inspect --format '{{.State.Pid}}' $(docker ps | grep "$fkwd" | awk '{print $1}'))
        else
          echo "====== More than one container ======"
          conts=$(docker ps --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          conts=($conts)
          IFS=$SIFS
          for ((i = 0; i < ${#conts[@]}; i++)); do
            echo "$i: ${conts[$i]}"
          done
          read -p "====== select one with number[0]: " dcidx
          if [ -z "$dcidx" ]; then
            dcidx=0
          fi
          pid=$(docker inspect --format '{{.State.Pid}}' $(echo ${conts[$dcidx]} | awk '{print $1}'))
        fi
        ps -aelfx | grep -- " $(ps -o ppid= $pid) \| $pid " | grep -v "grep" 
      fi
    elif [ "$subcmd" == "die" ] || [ "$subcmd" == "diexe" ] || [ "$subcmd" == "diexec" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker exec -it $(docker ps -a | grep "$fkwd" | awk '{print $1}') sh
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker exec -it $(echo ${cimgs[$diidx]} | awk '{print $1}') sh
        fi
      else
        cmd="docker exec -it $fkwd sh"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dat" ] || [ "$subcmd" == "dattach" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker attach $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker attach $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker attach $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dlg" ] || [ "$subcmd" == "dlog" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker logs $(docker ps -a | grep "$fkwd" | awk '{print $1}') $since $amount
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker logs $(echo ${cimgs[$diidx]} | awk '{print $1}') $since $amount
        fi
      else
        cmd="docker logs $fkwd $since $amount"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dlf" ] || [ "$subcmd" == "dlogf" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ -n "$fkwd" ] && [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker logs -f $(docker ps -a | grep "$fkwd" | awk '{print $1}') $since $amount
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker logs -f $(echo ${cimgs[$diidx]} | awk '{print $1}') $since $amount
        fi
      else
        cmd="docker logs -f $fkwd $since $amount"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dmi" ] || [ "$subcmd" == "dmin" ] || [ "$subcmd" == "dminsp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [[ "$fkwd" =~ ":" ]]; then
          docker inspect "$fkwd"
          exit 0
        fi
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect $(docker images | grep "$fkwd" | awk '{print $3}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect $(echo ${cimgs[$diidx]} | awk '{print $3}')
        fi
      else
        cmd="docker inspect $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "di" ] || [ "$subcmd" == "din" ] || [ "$subcmd" == "dinsp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        echo "A"
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dsa" ] || [ "$subcmd" == "dstart" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker start $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker start $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker start $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dsp" ] || [ "$subcmd" == "dstop" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker stop $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one or more with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          for item in ${diidx[@]}; do
            docker stop $(echo ${cimgs[$item]} | awk '{print $1}')
          done
        fi
      else
        cmd="docker stop $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dtp" ] || [ "$subcmd" == "dtop" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker top $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker top $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker top $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dst" ] || [ "$subcmd" == "dstat" ] || [ "$subcmd" == "dstat" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ -z "$fkwd" ]; then
          docker stats
        elif [ $(docker ps | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker stats $(docker ps | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker stats $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker stats $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dt" ] || [ "$subcmd" == "dtg" ] || [ "$subcmd" == "dtag" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        echo "error: need arguments"
        exit 1
      else
        ttag="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [[ "$fkwd" =~ ":" ]]; then
          docker tag "$fkwd" $ttag
          exit 0
        fi
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker tag $(docker images | grep "$fkwd" | awk '{print $3}') $ttag
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker tag $(echo ${cimgs[$diidx]} | awk '{print $3}') $ttag
        fi
      else
        cmd="docker tag $fkwd $ttag"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "drmn" ]; then
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        docker rmi -f $(docker image ls | grep '<none>' | awk '{print $3}')
      else
        cmd="docker rmi -f $(docker image ls | grep '<none>' | awk '{print $3}')"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "do" ] || [ "$subcmd" == "drmi" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [[ "$fkwd" =~ ":" ]]; then
          docker rmi -f "$fkwd"
          exit 0
        fi
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          if [[ $(docker images | grep "$fkwd" | awk '{print $1}') == "<none>" ]]; then
            docker rmi -f $(docker images | grep "$fkwd" | awk '{print $3}')
          else
            docker rmi -f $(docker images | grep "$fkwd" | awk '{print $1":"$2}')
          fi
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          echo "-1: ALL"
          read -p "====== select one or more with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          for item in ${diidx[@]}; do
            if [ $item -eq -1 ]; then
              docker rmi -f $(docker images | grep "$fkwd" | awk '{print $1":"$2}')
            else
              if [ $(echo ${cimgs[$item]} | awk '{print $1}') == "<none>" ]; then
                docker rmi -f $(echo ${cimgs[$item]} | awk '{print $3}')
              else
                docker rmi -f $(echo ${cimgs[$item]} | awk '{print $1":"$2}')
              fi
            fi
          done
        fi
      else
        cmd="docker rmi -f $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dh" ] || [ "$subcmd" == "dhi" ] || [ "$subcmd" == "dhist" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [[ "$fkwd" =~ ":" ]]; then
          docker history "$fkwd"
          exit 0
        fi
        if [ $(docker images | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker history $(docker images | grep "$fkwd" | awk '{print $3}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker image list --format '{{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker history $(echo ${cimgs[$diidx]} | awk '{print $3}')
        fi
      else
        cmd="docker history $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpa" ] || [ "$subcmd" == "daddr" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .NetworkSettings.Networks}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect --format='{{json .NetworkSettings.Networks}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .NetworkSettings.Networks}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpe" ] || [ "$subcmd" == "denv" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .Config.Env}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect --format='{{json .Config.Env}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .Config.Env}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpl" ] || [ "$subcmd" == "dlp" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .LogPath}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect --format='{{json .LogPath}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .LogPath}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpc" ] || [ "$subcmd" == "dcmd" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .Config.Cmd}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect --format='{{json .Config.Cmd}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .Config.Cmd}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpp" ] || [ "$subcmd" == "dport" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .NetworkSettings.Ports}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect --format='{{json .NetworkSettings.Ports}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .NetworkSettings.Ports}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dpm" ] || [ "$subcmd" == "dmnt" ]; then
      if [ -n "$kwd" ]; then
        fkwd="$kwd"
      elif [ ${#mandatory[@]} -gt 0 ]; then
        fkwd="${mandatory[0]}"
        mandatory=("${mandatory[@]:1}")
      fi
      if [ ${#mandatory[@]} -lt 1 ]; then
        require docker
        if [ $(docker ps -a | grep "$fkwd" | wc -l) -lt 2 ]; then
          docker inspect --format='{{json .Mounts}}' $(docker ps -a | grep "$fkwd" | awk '{print $1}')
        else
          echo "====== More than one container ======"
          cimgs=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' | grep "$fkwd")
          SIFS=$IFS
          IFS=$'\n'
          cimgs=($cimgs)
          IFS=$SIFS
          for ((i = 0; i < ${#cimgs[@]}; i++)); do
            echo "$i: ${cimgs[$i]}"
          done
          read -p "====== select one with number[0]: " diidx
          if [ -z "$diidx" ]; then
            diidx=0
          fi
          docker inspect --format='{{json .Mounts}}' $(echo ${cimgs[$diidx]} | awk '{print $1}')
        fi
      else
        cmd="docker inspect --format='{{json .Mounts}}' $fkwd"
        for ip in ${mandatory[@]}; do
          execmd "$cmd" $ip
        done
      fi
    elif [ "$subcmd" == "dck" ] || [ "$subcmd" == "dcheck" ]; then
      require curl
      if [ ${#mandatory[@]} -gt 3 ]; then
        regurl="${mandatory[0]}"
        reguser="${mandatory[1]}"
        regpasswd="${mandatory[2]}"

        mandatory=("${mandatory[@]:3}")
        imagelist="${mandatory[3]}"
        if [ -f "$imagelist" ]; then
          while read line
          do
            checkimage $line $regurl $reguser $regpasswd
            sleep 1
          done < $imagelist
        else
          for line in ${mandatory[@]}
          do
            checkimage $line $regurl $reguser $regpasswd
            sleep 1
          done
        fi
      else
        echo "error: need arguments"
      fi
    elif [ "$subcmd" == "cf" ] || [ "$subcmd" == "cfind" ]; then
      grep -nr "${mandatory[*]}"
    elif [ "$subcmd" == "df" ] || [ "$subcmd" == "dfind" ]; then
      require docker
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi

      items=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Command}}\t{{.Status}}' 2>/dev/null)
      SIFS=$IFS
      IFS=$'\n'
      items=($items)
      IFS=$SIFS

      for ((i = 0; i < ${#items[@]}; i++)); do
        lid=$(echo ${items[$i]} | awk '{print $1}')
        if [ $(docker inspect $lid | grep "$kwd" | wc -l) -gt 0 ]; then
          echo ${items[$i]}
        fi
      done
    elif [ "$subcmd" == "kg" ] || [ "$subcmd" == "gencfg" ]; then
      require kubectl
      shift
      apiserver=$1
      certdir=${2:-"/etc/kubernetes/ssl"}

      kubectl config set-cluster default-cluster --server=${apiserver} \
        --certificate-authority=${certdir}/kube-ca.pem \
        --embed-certs=true \
        --kubeconfig=admin.kubeconfig

      kubectl config set-credentials default-admin \
        --certificate-authority=${certdir}/kube-ca.pem \
        --embed-certs=true \
        --client-key=${certdir}/admin-key.pem \
        --client-certificate=${certdir}/admin.pem \
        --kubeconfig=admin.kubeconfig

      kubectl config set-context default-system --cluster=default-cluster \
        --user=default-admin \
        --kubeconfig=admin.kubeconfig

      kubectl config use-context default-system --kubeconfig=admin.kubeconfig
    elif [ "$subcmd" == "cfg" ] || [ "$subcmd" == "config" ]; then
      require kubectl
      ctgt="${mandatory[*]}"
      if [ -z $ctgt ]; then
        kubectl $kc $context config view
      elif [ "$ctgt" == "ctx" ] || [ "$ctgt" == "context" ]; then
        kubectl $kc $context config view -o jsonpath='{.contexts[*].name}'
      elif [ "$ctgt" == "user" ]; then
        kubectl $kc $context config view -o jsonpath='{.users[*].name}'
      elif [ "$ctgt" == "cluster" ]; then
        kubectl $kc $context config view -o jsonpath='{.clusters[*].name}'
      else
        cur=$(kubectl $kc $context config view -o jsonpath='{.current-context}')
        for ctx in $(kubectl $kc $context config view -o jsonpath='{.contexts[*].name}'); do
          #echo $ctx
          u=$(kubectl $kc $context config view -o jsonpath="{.contexts[?(@.name==\"$ctx\")].context.user}")
          c=$(kubectl $kc $context config view -o jsonpath="{.contexts[?(@.name==\"$ctx\")].context.cluster}")
          cluster=$(kubectl $kc $context config view -o jsonpath="{.clusters[?(@.name==\"$c\")].cluster.server}")
          if [ "$ctx" == "$cur" ]; then
            echo "*[$ctx] <$u> $cluster"
          else
            echo " [$ctx] <$u> $cluster"
          fi
        done
      fi
    elif [ "$subcmd" == "dump" ]; then
      require kubectl
      kubectl $kc $context cluster-info dump
    elif [ "$subcmd" == "exp" ] || [ "$subcmd" == "explain" ]; then
      require kubectl
      if [ ${#mandatory[@]} -gt 0 ]; then
        kubectl $kc $context explain ${mandatory[@]}
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "expr" ] || [ "$subcmd" == "explainr" ]; then
      require kubectl
      if [ ${#mandatory[@]} -gt 0 ]; then
        kubectl $kc $context explain ${mandatory[@]} --recursive
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "dry" ] || [ "$subcmd" == "dryrun" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        kubectl $kc $context ${mandatory[@]} --dry-run
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "ap" ] || [ "$subcmd" == "apl" ] || [ "$subcmd" == "apply" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        for fname in ${mandatory[@]}; do
          kubectl $kc $context apply -f $fname $selector $ns $dryrun $output
        done
      else
        echo "error: need arguments"
        exit 1
      fi
    elif ([ "$subcmd" == "rm" ] || [ "$subcmd" == "del" ] || [ "$subcmd" == "delete" ]) && ([[ ${mandatory[0]} =~ .yaml$ ]] || [[ ${mandatory[0]} =~ .yml$ ]] || [[ ${mandatory[0]} =~ .json$ ]]); then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        for fname in ${mandatory[@]}; do
          kubectl $kc $context delete -f $fname $selector $ns $dryrun $output
        done
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "cr" ] || [ "$subcmd" == "crt" ] || [ "$subcmd" == "create" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 0 ]; then
        isfile="true"
        for fname in ${mandatory[@]}; do
          if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
            isfile="false"
            break
          fi
        done
        if [ "$isfile" == "true" ]; then
          for fname in ${mandatory[@]}; do
            kubectl $kc $context create -f $fname $selector $ns $dryrun $output
          done
        else
          if [ -z "$kind" ] && [[ ! "${mandatory[*]}" =~ ":" ]]; then
            kind=$(aliasKind ${mandatory[0]})
            mandatory=("${mandatory[@]:1}")
          fi
          kubectl $kc $context create $kind ${mandatory[@]} $selector $ns $dryrun $output
        fi
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "r" ] || [ "$subcmd" == "run" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 1 ]; then
        kubectl $kc $context run ${mandatory[@]} $ns $dryrun $output
      else
        echo "error: need arguments"
        exit 1
      fi
    elif [ "$subcmd" == "b" ] || [ "$subcmd" == "rbac" ]; then
      require kubectl rback dot
      if [ -n "$savedir" ]; then
        kubectl $kc $context get sa,roles,rolebindings,clusterroles,clusterrolebindings $ns -o json | rback -show-legend=false ${mandatory[*]} | dot -Tsvg >$savedir/rbac.svg
      else
        dispapp="xdg-open"
        if type display &>/dev/null; then
          dispapp="display"
        elif type inkview &>/dev/null; then
          dispapp="inkview"
        elif type feh &>/dev/null; then
          dispapp="feh --conversion-timeout 1"
        fi
        kubectl $kc $context get sa,roles,rolebindings,clusterroles,clusterrolebindings $ns -o json | rback -show-legend=false ${mandatory[*]} | dot -Tsvg | $dispapp
      fi
    elif [ "$subcmd" == "a" ] || [ "$subcmd" == "all" ]; then
      require kubectl
      kubectl $kc $context get all $selector $ns $dryrun $output
    elif [ "$subcmd" == "ee" ] || [ "$subcmd" == "etcd" ] || [ "$subcmd" == "etcdexe" ]; then
      require etcdctl
      emode=${mandatory[0]}
      mandatory=("${mandatory[@]:1}")
      if [ -d /etc/kubernetes/pki ]; then
        rpath="/etc/kubernetes/pki"
      elif [ -d /etc/kubernetes/ssl ]; then
        rpath="/etc/kubernetes/ssl"
      else
        rpath="."
      fi
      if [ -z "$host" ]; then
        host="127.0.0.1"
      fi
      if [ -z "$port" ]; then
        port="2379"
      fi
      ep="$host:$port"
      if [ ${#mandatory[@]} -le 2 ]; then
        if [ -f $rpath/ca.crt ]; then
          ca=$rpath/ca.crt
        else
          ca=$rpath/kube-ca.pem
        fi
        if [ -f $rpath/etcd/peer.crt ]; then
          cert=$rpath/etcd/peer.crt
        else
          cert=$rpath/$(ls $rpath | grep etcd | grep -v key.pem | sed -n '1p')
        fi
        if [ -f $rpath/etcd/peer.key ]; then
          key=$rpath/etcd/peer.key
        else
          key=$rpath/$(ls $rpath | grep etcd | grep key.pem | sed -n '1p')
        fi
        etcdargs="${mandatory[*]}"
      else
        ca=${mandatory[0]}
        cert=${mandatory[1]}
        key=${mandatory[2]}
        etcdargs="${mandatory[@]:3}"
        if [ "${ca:0:1}" != "/" ]; then
          ca=$rpath/$ca
        fi
        if [ "${cert:0:1}" != "/" ]; then
          cert=$rpath/$cert
        fi
        if [ "${key:0:1}" != "/" ]; then
          key=$rpath/$key
        fi
      fi

      # echo "=== endpoint: $ep | cacert: $ca | cert: $cert | key: $key ==="
      if [ "$emode" == "h" ] || [ "$emode" == "hp" ] || [ "$emode" == "help" ]; then
        echo '
USAGE:
  COMMAND:
    kude etcd -h [host] -p [port] <mode> <args>
  MODES:
    get,key: get the value of the key from etcd
    getp,keyp: get the value and sub path of the key from etcd
    meta: get etcd meta keys
    status: get etcd endpoint status
    ctl,run,cmd: execute etcdctl command
    list: list etcd member
    perf: check etcd perf
  EXAMPLES:
    kude etcd status
    kude etcd -h 127.0.0.1 -p 2379 get /registry/namespaces/default
    kude etcd -p 2379 cmd ca.crt server.crt server.key endpoint health
    '
      elif [ "$emode" == "get" ] || [ "$emode" == "key" ]; then
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key get "$etcdargs" -w=json
      elif [ "$emode" == "getp" ] || [ "$emode" == "keyp" ]; then
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key get "$etcdargs" --prefix -w=json
      elif [ "$emode" == "meta" ]; then
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key get / --prefix --keys-only
      elif [ "$emode" == "status" ]; then
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key endpoint status
      elif [ "$emode" == "list" ]; then
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key member list
      elif [ "$emode" == "perf" ]; then
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key check perf
      else
        ETCDCTL_API=3 etcdctl --endpoints=$ep --cacert=$ca --cert=$cert --key=$key $etcdargs
      fi
    elif [ "$subcmd" == "np" ] || [ "$subcmd" == "nodepod" ]; then
      require kubectl
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi
      nodes=$(kubectl $kc $context get node $selector -o wide --no-headers | grep "$kwd")
      SIFS=$IFS
      IFS=$'\n'
      nodes=($nodes)
      IFS=$SIFS
      if [ ${#nodes[@]} -eq 0 ]; then
        exit 0
      elif [ ${#nodes[@]} -eq 1 ]; then
        node=${nodes[0]}
      else
        echo "====== More than one node ======"
        for ((i = 0; i < ${#nodes[@]}; i++)); do
          echo "$i: ${nodes[$i]}"
        done
        read -p "====== select one with number[0]: " niidx
        if [ -z "$niidx" ]; then
          niidx=0
        fi
        node=${nodes[$niidx]}
      fi
      nodeip=$(echo "$node" | awk '{print $6}')
      nodename=$(echo "$node" | awk '{print $1}')
      kubectl $kc $context get pod -o wide $selector $ns | grep -E "NAME| $nodeip | $nodename "
    elif [ "$subcmd" == "ni" ] || [ "$subcmd" == "nodeimg" ]; then
      require kubectl
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi
      nodes=$(kubectl $kc $context get node $selector -o wide --no-headers | grep "$kwd")
      SIFS=$IFS
      IFS=$'\n'
      nodes=($nodes)
      IFS=$SIFS
      if [ ${#nodes[@]} -eq 0 ]; then
        exit 0
      elif [ ${#nodes[@]} -eq 1 ]; then
        node=${nodes[0]}
      else
        echo "====== More than one node ======"
        for ((i = 0; i < ${#nodes[@]}; i++)); do
          echo "$i: ${nodes[$i]}"
        done
        read -p "====== select one with number[0]: " niidx
        if [ -z "$niidx" ]; then
          niidx=0
        fi
        node=${nodes[$niidx]}
      fi
      nodename=$(echo "$node" | awk '{print $1}')
      kubectl get node $nodename -o jsonpath='{.status.images[*].names[*]}' | sed 's/ /\n/g' | grep -v "@sha256"
    elif [ "$subcmd" == "cs" ] || [ "$subcmd" == "crtsec" ] || [ "$subcmd" == "createsecret" ]; then
      require kubectl
      if [ "$ns" == "--all-namespaces" ]; then
        ns=""
      fi
      if [ ${#mandatory[@]} -gt 1 ]; then
        sscmd=${mandatory[0]}
        resname=${mandatory[1]}
        mandatory=("${mandatory[@]:2}")
        if [ ${#mandatory[@]} -lt 1 ]; then
          cshelp
          exit 1
        fi
        if [ "$sscmd" == "h" ] || [ "$sscmd" == "hp" ] || [ "$sscmd" == "help" ]; then
          cshelp
          exit 0
        elif [ "$sscmd" == "g" ] || [ "$sscmd" == "gl" ] || [ "$sscmd" == "generic-literal" ]; then
          literals=""
          for ((i = 0; i < ${#mandatory[@]}; i++)); do
            literals="$literals --from-literal=${mandatory[$i]}"
          done
          kubectl $kc $context create secret generic $resname $literals $selector $ns $dryrun $output
        elif [ "$sscmd" == "gf" ] || [ "$sscmd" == "generic-file" ]; then
          files=""
          for ((i = 0; i < ${#mandatory[@]}; i++)); do
            files="$files --from-file=${mandatory[$i]}"
          done
          kubectl $kc $context create secret generic $resname $files $selector $ns $dryrun $output
        elif [ "$sscmd" == "ge" ] || [ "$sscmd" == "generic-env" ]; then
          kubectl $kc $context create secret generic $resname --from-env-file=${mandatory[0]} $selector $ns $dryrun $output
        elif [ "$sscmd" == "dr" ] || [ "$sscmd" == "dr" ] || [ "$sscmd" == "docker-registry" ]; then
          if [ ${#mandatory[@]} -lt 3 ]; then
            cshelp
            exit 1
          fi
          dserver=${mandatory[0]}
          duname=${mandatory[1]}
          dpasswd=${mandatory[2]}
          kubectl $kc $context create secret docker-registry $resname --docker-server=$dserver --docker-username=$duname --docker-password=$dpasswd $selector $ns $dryrun $output
        elif [ "$sscmd" == "t" ] || [ "$sscmd" == "tl" ] || [ "$sscmd" == "tls" ]; then
          if [ ${#mandatory[@]} -lt 2 ]; then
            cshelp
            exit 1
          fi
          tlscert=${mandatory[0]}
          tlskey=${mandatory[1]}
          kubectl $kc $context create secret tls $resname --cert=$tlscert --key=$tlskey $selector $ns $dryrun $output
        else
          cshelp
          exit 1
        fi
      else
        cshelp
        exit 1
      fi
    elif [ "$subcmd" == "tk" ] || [ "$subcmd" == "token" ]; then
      require kubectl base64
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi
      sas=$(kubectl $kc $context get serviceaccount --no-headers $selector $ns | grep "$kwd")
      SIFS=$IFS
      IFS=$'\n'
      sas=($sas)
      IFS=$SIFS
      if [ ${#sas[@]} -eq 0 ]; then
        exit 0
      elif [ ${#sas[@]} -eq 1 ]; then
        sa=${sas[0]}
      else
        echo "====== More than one serviceaccount ======"
        for ((i = 0; i < ${#sas[@]}; i++)); do
          echo "$i: ${sas[$i]}"
        done
        read -p "====== select one with number[0]: " siidx
        if [ -z "$siidx" ]; then
          siidx=0
        fi
        sa=${sas[$siidx]}
      fi
      if [ "$ns" == "--all-namespaces" ]; then
        lns=$(echo "$sa" | awk '{print $1}')
        lrs=$(echo "$sa" | awk '{print $2}')
      else
        lns=$(echo "$ns" | awk '{print $2}')
        lrs=$(echo "$sa" | awk '{print $1}')
      fi
      kubectl $kc $context -n $lns get secret $(kubectl $kc $context get serviceaccount $lrs -n $lns -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode
    elif [ "$subcmd" == "re" ] || [ "$subcmd" == "res" ]; then
      require kubectl
      kubectl $kc $context api-resources
    elif [ "$subcmd" == "ver" ] || [ "$subcmd" == "version" ]; then
      require kubectl
      kubectl $kc $context api-versions
    elif [ "$subcmd" == "ro" ] || [ "$subcmd" == "rollout" ]; then
      require kubectl
      kubectl $kc $context rollout ${mandatory[@]} $selector $ns $dryrun $output
    elif [ "$subcmd" == "au" ] || [ "$subcmd" == "auth" ]; then
      require kubectl
      kubectl $kc $context auth "${mandatory[@]}" $ns $dryrun $output
    elif [ "$subcmd" == "pr" ] || [ "$subcmd" == "proxy" ]; then
      require kubectl
      if [[ "${mandatory[*]}" =~ ":" ]]; then
        ip=$(echo "${mandatory[*]}" | awk -F ':' '{print $1}')
        pt=$(echo "${mandatory[*]}" | awk -F ':' '{print $2}')
      else
        pt=${mandatory[*]}
      fi
      if [ -z "$ip" ]; then
        ip="127.0.0.1"
      fi
      if [ -z "$pt" ]; then
        if [ -n "$port" ]; then
          pt=$port
        else
          pt="8001"
        fi
      fi
      kubectl $kc $context proxy --address $ip --port $pt $dryrun $output
    elif [ "$subcmd" == "li" ] || [ "$subcmd" == "lsimg" ]; then
      require kubectl
      # kubectl get pods --all-namespaces -o jsonpath="{.items[*].spec.containers[*].image}"
      echo $(kubectl $kc $context get pod -o go-template --template="{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}" $selector $ns) | sed 's/ /\n/g' | sort | uniq | tr '\n' ' '
    elif [ "$subcmd" == "lli" ] || [ "$subcmd" == "llimg" ]; then
      kubectl $kc $context get pod -o=jsonpath='{range .items[*]}{"\n"}{.metadata.name}{":\t"}{range .spec.containers[*]}{.image}{", "}{end}{end}' $selector $ns | sort
    elif [ "$subcmd" == "kf" ] || [ "$subcmd" == "kfind" ]; then
      require kubectl
      if [ -z "$kwd" ] && [ ${#mandatory[@]} -gt 0 ]; then
        kwd="${mandatory[*]}"
      fi

      if [ -z "$kind" ]; then
        kind="pod"
      fi
      items=$(kubectl $kc $context get $kind --no-headers $selector $ns 2>/dev/null)
      SIFS=$IFS
      IFS=$'\n'
      items=($items)
      IFS=$SIFS

      for ((i = 0; i < ${#items[@]}; i++)); do
        if [ "$ns" == "--all-namespaces" ]; then
          lns=$(echo ${items[$i]} | awk '{print $1}')
          lrs=$(echo ${items[$i]} | awk '{print $2}')
        else
          lns=$(echo "$ns" | awk '{print $2}')
          lrs=$(echo ${items[$i]} | awk '{print $1}')
        fi

        if [ $(kubectl $kc $context -n $lns $selector get $kind $lrs -o yaml | grep "$kwd" | wc -l) -gt 0 ]; then
          echo -e "$lns\t$lrs"
        fi
      done
    else
      require kubectl
      if [ -z "$kind" ]; then
        if [ ${#mandatory[@]} -gt 0 ] && [ "$subcmd" != "l" ] && [ "$subcmd" != "log" ] && [ "$subcmd" != "lf" ] && [ "$subcmd" != "logf" ] && [ "$subcmd" != "i" ] && [ "$subcmd" != "insp" ] && [ "$subcmd" != "inspect" ] && [ "$subcmd" != "e" ] && [ "$subcmd" != "exe" ] && [ "$subcmd" != "exec" ] && [ "$subcmd" != "ie" ] && [ "$subcmd" != "iexe" ] && [ "$subcmd" != "iexec" ] && [ "$subcmd" != "at" ] && [ "$subcmd" != "attach" ] && [ "$subcmd" != "cp" ] && [ "$subcmd" != "copy" ] && [ "$subcmd" != "pf" ] && [ "$subcmd" != "forward" ] && [ "$subcmd" != "port-forward" ] && [ "$subcmd" != "x" ] && [ "$subcmd" != "dbg" ] && [ "$subcmd" != "debug" ]; then
          kind=$(aliasKind ${mandatory[0]})
          mandatory=("${mandatory[@]:1}")
        else
          kind="pod"
        fi
      fi
      if [ -z "$kwd" ]; then
        if [ ${#mandatory[@]} -gt 0 ]; then
          kwd=${mandatory[0]}
        fi
        if [ ${#mandatory[@]} -gt 1 ]; then
          args=${mandatory[@]:1}
        fi
      else
        args=${mandatory[@]}
      fi
      if [ -z "$kwd" ] || [ $list -eq 1 ]; then
        case $subcmd in
        "f" | "gt" | "get")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns
          fi
          ;;
        "wt" | "watch")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns --watch | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns --watch
          fi
          ;;
        "l" | "log")
          if [ "$ns" == "--all-namespaces" ]; then
            ns="default"
          fi
          if [ "$kind" == "pod" ]; then
            kubectl $kc $context logs $selector $since $amount $ns --all-containers --max-log-requests 100
          else
            echo "subcmd log not fit for $kind"
          fi
          ;;
        "lf" | "logf")
          if [ "$ns" == "--all-namespaces" ]; then
            ns="default"
          fi
          if [ "$kind" == "pod" ]; then
            kubectl $kc $context logs -f $selector $since $amount $ns --all-containers --max-log-requests 100
          else
            echo "subcmd logf not fit for $kind"
          fi
          ;;
        "lb" | "lba" | "lbo" | "lbao" | "label" | "labela" | "labelo" | "labelao")
          lbow=""
          if [[ "$subcmd" == "lbo" ]] || [[ "$subcmd" == "lbao" ]] || [[ "$subcmd" == "labelo" ]] || [[ "$subcmd" == "labelao" ]]; then
            lbow="--overwrite"
          fi
          if [[ "$subcmd" == "lba" ]] || [[ "$subcmd" == "lbao" ]] || [[ "$subcmd" == "labela" ]] || [[ "$subcmd" == "labelao" ]] || [[ "$kwd" =~ "-" ]] || [[ "$kwd" =~ "=" ]]; then
            args=$kwd" "$args
            kwd=""
            kubectl $kc $context label $lbow $kind --all $args $ns $dryrun $output
            exit 0
          fi
          items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd")
          SIFS=$IFS
          IFS=$'\n'
          items=($items)
          IFS=$SIFS
          if [ ${#items[@]} -eq 0 ]; then
            exit 0
          elif [ ${#items[@]} -eq 1 ]; then
            item=${items[0]}
            if [ "$ns" == "--all-namespaces" ]; then
              lns=$(echo "$item" | awk '{print $1}')
              lrs=$(echo "$item" | awk '{print $2}')
            else
              lns=$(echo "$item" | awk '{print $2}')
              lrs=$(echo "$item" | awk '{print $1}')
            fi
            kubectl $kc $context -n $lns label $lbow $kind $lrs $args $dryrun $output
          else
            echo "====== More than one $kind ======"
            for ((i = 0; i < ${#items[@]}; i++)); do
              echo "$i: ${items[$i]}"
            done
            echo "-1: ALL"
            read -p "====== select one with number[0]: " liidx
            if [ -z "$liidx" ]; then
              liidx=0
            fi
            if [ $liidx -eq -1 ]; then
              for ((i = 0; i < ${#items[@]}; i++)); do
                item=${items[$i]}
                if [ "$ns" == "--all-namespaces" ]; then
                  lns=$(echo "$item" | awk '{print $1}')
                  lrs=$(echo "$item" | awk '{print $2}')
                else
                  lns=$(echo "$item" | awk '{print $2}')
                  lrs=$(echo "$item" | awk '{print $1}')
                fi
                kubectl $kc $context -n $lns label $lbow $kind $lrs $args $dryrun $output
              done
            else
              item=${items[$liidx]}
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo "$item" | awk '{print $1}')
                lrs=$(echo "$item" | awk '{print $2}')
              else
                lns=$(echo "$item" | awk '{print $2}')
                lrs=$(echo "$item" | awk '{print $1}')
              fi
              kubectl $kc $context -n $lns label $lbow $kind $lrs $args $dryrun $output
            fi
          fi
          ;;
        "w" | "wide")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns -o wide | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns -o wide
          fi
          ;;
        "wl" | "wlabel")
          if [ -n "$kwd" ]; then
            kubectl $kc $context get $kind $selector $ns -o wide --show-labels | grep "$kwd"
          else
            kubectl $kc $context get $kind $selector $ns -o wide --show-labels
          fi
          ;;
        "s" | "desc" | "describe")
          if [ -n "$kwd" ]; then
            items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
            SIFS=$IFS
            IFS=$'\n'
            items=($items)
            IFS=$SIFS
            for ((i = 0; i < ${#items[@]}; i++)); do
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo ${items[$i]} | awk '{print $1}')
                lrs=$(echo ${items[$i]} | awk '{print $2}')
              else
                lns=$(echo "$ns" | awk '{print $2}')
                lrs=$(echo ${items[$i]} | awk '{print $1}')
              fi
              kubectl $kc $context -n $lns $selector describe $kind $lrs
            done
          else
            kubectl $kc $context describe $kind $selector $ns
          fi
          ;;
        "y" | "yn" | "yaml")
          if [ -n "$kwd" ]; then
            items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
            SIFS=$IFS
            IFS=$'\n'
            items=($items)
            IFS=$SIFS
            for ((i = 0; i < ${#items[@]}; i++)); do
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo ${items[$i]} | awk '{print $1}')
                lrs=$(echo ${items[$i]} | awk '{print $2}')
              else
                lns=$(echo "$ns" | awk '{print $2}')
                lrs=$(echo ${items[$i]} | awk '{print $1}')
              fi
              if [ $neat -eq 0 ] && [ "$subcmd" != "yn" ]; then
                kubectl $kc $context -n $lns $selector get $kind $lrs -o yaml
              else
                require yq
                kubectl $kc $context -n $lns $selector get $kind $lrs -o yaml | yq d - items.*.status | yq d - items.*.metadata.ownerReferences | yq d - items.*.metadata.managedFields | yq d - 'metadata.annotations."kubectl.kubernetes.io/last-applied-configuration"' | yq d - items.*.metadata.creationTimestamp | yq d - items.*.metadata.generation | yq d - items.*.metadata.generateName | yq d - items.*.metadata.resourceVersion | yq d - items.*.metadata.selfLink | yq d - items.*.metadata.uid | yq d - items.*.spec.template.metadata.creationTimestamp | yq d - status | yq d - metadata.ownerReferences | yq d - metadata.managedFields | yq d - metadata.creationTimestamp | yq d - metadata.generation | yq d - metadata.generateName | yq d - metadata.resourceVersion | yq d - metadata.selfLink | yq d - metadata.uid | yq d - spec.template.metadata.creationTimestamp | grep -v 'progressDeadlineSeconds: 600' | grep -v 'revisionHistoryLimit: 10' | grep -v 'dnsPolicy: ClusterFirst' | grep -v 'dnsConfig: {}' | grep -v 'enableServiceLinks: true' | grep -v 'priority: 0' | grep -v 'restartPolicy: Always' | grep -v 'schedulerName: default-scheduler' | grep -v 'securityContext: {}' | grep -v 'serviceAccountName: default' | grep -v 'terminationGracePeriodSeconds: 30' | grep -v 'terminationMessagePath: /dev/termination-log' | grep -v 'terminationMessagePolicy: File' | grep -v 'imagePullPolicy: IfNotPresent' | grep -v 'resources: {}' | grep -v 'stdin: true' | grep -v 'tty: true'
              fi
            done
          else
            if [ $neat -eq 0 ] && [ "$subcmd" != "yn" ]; then
              kubectl $kc $context get $kind $selector $ns -o yaml
            else
              require yq
              kubectl $kc $context get $kind $selector $ns -o yaml | yq d - items.*.status | yq d - items.*.metadata.ownerReferences | yq d - items.*.metadata.managedFields | yq d - 'items.*.metadata.annotations."kubectl.kubernetes.io/last-applied-configuration"' | yq d - items.*.metadata.creationTimestamp | yq d - items.*.metadata.generation | yq d - items.*.metadata.generateName | yq d - items.*.metadata.resourceVersion | yq d - items.*.metadata.selfLink | yq d - items.*.metadata.uid | yq d - items.*.spec.template.metadata.creationTimestamp | yq d - status | yq d - metadata.ownerReferences | yq d - metadata.managedFields | yq d - metadata.creationTimestamp | yq d - metadata.generation | yq d - metadata.generateName | yq d - metadata.resourceVersion | yq d - metadata.selfLink | yq d - metadata.uid | yq d - spec.template.metadata.creationTimestamp | grep -v 'progressDeadlineSeconds: 600' | grep -v 'revisionHistoryLimit: 10' | grep -v 'dnsPolicy: ClusterFirst' | grep -v 'dnsConfig: {}' | grep -v 'enableServiceLinks: true' | grep -v 'priority: 0' | grep -v 'restartPolicy: Always' | grep -v 'schedulerName: default-scheduler' | grep -v 'securityContext: {}' | grep -v 'serviceAccountName: default' | grep -v 'terminationGracePeriodSeconds: 30' | grep -v 'terminationMessagePath: /dev/termination-log' | grep -v 'terminationMessagePolicy: File' | grep -v 'imagePullPolicy: IfNotPresent' | grep -v 'resources: {}' | grep -v 'stdin: true' | grep -v 'tty: true'
            fi
          fi
          ;;
        "j" | "jn" | "json")
          if [ -n "$kwd" ]; then
            items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
            SIFS=$IFS
            IFS=$'\n'
            items=($items)
            IFS=$SIFS
            for ((i = 0; i < ${#items[@]}; i++)); do
              if [ "$ns" == "--all-namespaces" ]; then
                lns=$(echo ${items[$i]} | awk '{print $1}')
                lrs=$(echo ${items[$i]} | awk '{print $2}')
              else
                lns=$(echo "$ns" | awk '{print $2}')
                lrs=$(echo ${items[$i]} | awk '{print $1}')
              fi
              if [ $neat -eq 0 ] && [ "$subcmd" != "jn" ]; then
                kubectl $kc $context -n $lns $selector get $kind $lrs -o json
              else
                require jq
                kubectl $kc $context -n $lns $selector get $kind $lrs -o json | jq -rM 'del(.status)' | jq -rM 'del(.metadata.ownerReferences)' | jq -rM 'del(.metadata.managedFields)' | jq -rM 'del(.metadata.annotations."kubectl.kubernetes.io/last-applied-configuration")' | jq -rM 'del(.metadata.creationTimestamp)' | jq -rM 'del(.metadata.generation)' | jq -rM 'del(.metadata.generateName)' | jq -rM 'del(.metadata.resourceVersion)' | jq -rM 'del(.metadata.selfLink)' | jq -rM 'del(.metadata.uid)' | jq -rM 'del(.spec.template.metadata.creationTimestamp)' | grep -v '"progressDeadlineSeconds": 600' | grep -v '"revisionHistoryLimit": 10' | grep -v '"dnsPolicy": "ClusterFirst"' | grep -v '"dnsConfig": {}' | grep -v '"enableServiceLinks": true' | grep -v '"priority": 0' | grep -v '"restartPolicy": "Always"' | grep -v '"schedulerName": "default-scheduler"' | grep -v '"securityContext": {}' | grep -v '"serviceAccountName": "default"' | grep -v '"terminationGracePeriodSeconds": 30' | grep -v '"terminationMessagePath": "/dev/termination-log"' | grep -v '"terminationMessagePolicy": "File"' | grep -v '"imagePullPolicy": "IfNotPresent"' | grep -v '"resources": {}' | grep -v '"stdin": true' | grep -v '"tty": true'
              fi
            done
          else
            if [ $neat -eq 0 ] && [ "$subcmd" != "jn" ]; then
              kubectl $kc $context get $kind $selector $ns -o json
            else
              require jq
              kubectl $kc $context get $kind $selector $ns -o json | jq -rM 'del(.items[].status)' | jq -rM 'del(.items[].metadata.ownerReferences)' | jq -rM 'del(.items[].metadata.managedFields)' | jq -rM 'del(.items[].metadata.annotations."kubectl.kubernetes.io/last-applied-configuration")' | jq -rM 'del(.items[].metadata.creationTimestamp)' | jq -rM 'del(.items[].metadata.generation)' | jq -rM 'del(.items[].metadata.generateName)' | jq -rM 'del(.items[].metadata.resourceVersion)' | jq -rM 'del(.items[].metadata.selfLink)' | jq -rM 'del(.items[].metadata.uid)' | jq -rM 'del(.items[].spec.template.metadata.creationTimestamp)' | grep -v '"progressDeadlineSeconds": 600' | grep -v '"revisionHistoryLimit": 10' | grep -v '"dnsPolicy": "ClusterFirst"' | grep -v '"dnsConfig": {}' | grep -v '"enableServiceLinks": true' | grep -v '"priority": 0' | grep -v '"restartPolicy": "Always"' | grep -v '"schedulerName": "default-scheduler"' | grep -v '"securityContext": {}' | grep -v '"serviceAccountName": "default"' | grep -v '"terminationGracePeriodSeconds": 30' | grep -v '"terminationMessagePath": "/dev/termination-log"' | grep -v '"terminationMessagePolicy": "File"' | grep -v '"imagePullPolicy": "IfNotPresent"' | grep -v '"resources": {}' | grep -v '"stdin": true' | grep -v '"tty": true'
            fi
          fi
          ;;
        "tp" | "top")
          if [ "$ns" == "--all-namespaces" ]; then
            ns="-n default"
          fi
          if [ "$kind" == "pod" ] || [ "$kind" == "node" ]; then
            if [ -n "$kwd" ]; then
              if [ "$kind" == "node" ]; then
                kubectl $kc $context top $kind $selector $ns | grep "$kwd"
              else
                items=$(kubectl $kc $context get $kind --no-headers $selector $ns | grep "$kwd" 2>/dev/null)
                SIFS=$IFS
                IFS=$'\n'
                items=($items)
                IFS=$SIFS
                for ((i = 0; i < ${#items[@]}; i++)); do
                  if [ "$ns" == "--all-namespaces" ]; then
                    lns=$(echo ${items[$i]} | awk '{print $1}')
                    lrs=$(echo ${items[$i]} | awk '{print $2}')
                  else
                    lns=$(echo "$ns" | awk '{print $2}')
                    lrs=$(echo ${items[$i]} | awk '{print $1}')
                  fi
                  kubectl $kc $context -n $lns $selector top $kind $lrs
                done
              fi
            else
              kubectl $kc $context top $kind $selector $ns
            fi
          fi
          ;;
        esac
        exit 0
      fi

      hasnsfield="false"
      ress=()
      result=$(kubectl $kc $context get $kind $selector $ns 2>/dev/null)
      SIFS=$IFS
      IFS=$'\n'
      result=($result)
      IFS=$SIFS
      if [[ $(echo "${result[0]}" | awk '{print $1}') == "NAMESPACE" ]]; then
        hasnsfield="true"
      fi
      for ((i = 1; i < ${#result[@]}; i++)); do
        if [[ "${result[$i]}" =~ "$kwd" ]]; then
          ress+=("${result[$i]}")
        fi
      done
      #ress=($(echo ${result[@]:1} | grep "$kwd"))

      if [ $? -ne 0 ] || [ ${#ress[@]} -eq 0 ]; then
        echo "No $kind resources found with keyword $kwd"
        exit 1
      fi

      if [ ${#ress[@]} -eq 1 ]; then
        rs=$ress
      else
        echo "====== More than one $kind ======"
        for ((i = 0; i < ${#ress[@]}; i++)); do
          echo "$i: ${ress[$i]}"
        done
        # echo "====== Selected the first ======"
        read -p "====== select one with number[0]: " ridx
        if [ -z "$ridx" ]; then
          ridx=0
        fi
        rs=${ress[$ridx]}
      fi
      if [ "$ns" == "--all-namespaces" ]; then
        if [ "$hasnsfield" == "false" ]; then
          resname=$(echo $rs | awk '{print $1}')
        else
          resname=$(echo $rs | awk '{print $2}')
          namespace=$(echo $rs | awk '{print $1}')
          ns="-n $namespace"
        fi
      else
        resname=$(echo $rs | awk '{print $1}')
      fi

      if [ "$kind" == "pod" ] && [ "$subcmd" != "y" ] && [ "$subcmd" != "yn" ] && [ "$subcmd" != "yaml" ] && [ "$subcmd" != "j" ] && [ "$subcmd" != "jn" ] && [ "$subcmd" != "json" ]; then
        podinfo=$(kubectl $kc $context get pod $resname $ns -o=custom-columns=NODE:.spec.nodeName,HOST:.status.hostIP,NAME:.metadata.name,ADDR:.status.podIP,CNAME:.status.containerStatuses[$idx].name,CID:.status.containerStatuses[$idx].containerID 2>/dev/null | grep $resname)

        if [ $? -ne 0 ]; then
          echo "$resname[$idx] container not found"
          exit 1
        fi

        hname=$(echo $podinfo | awk '{print $1}')
        haddr=$(echo $podinfo | awk '{print $2}')
        pname=$(echo $podinfo | awk '{print $3}')
        caddr=$(echo $podinfo | awk '{print $4}')
        cname=$(echo $podinfo | awk '{print $5}')
        cid=$(echo $podinfo | awk '{print $6}')
        cid=${cid#*docker://}
        cid=${cid:0:12}

        echo "=================================================================================================================================================="
        echo "Namespace: "${ns#-n } "HostName: "$hname "HostIP:"$haddr "PodName:"$pname "PodIP:"$caddr "CName:"$cname "CID:"$cid
        echo "=================================================================================================================================================="

        if [ -n "$host" ]; then
          haddr=$host
        fi
      fi

      case $subcmd in
      "l" | "log")
        if [ "$kind" == "pod" ]; then
          if [ "$(hostname)" == "$hname" ] && type docker &>/dev/null; then
            docker logs $cid $since $amount
          else
            kubectl $kc $context logs $resname $cname $since $amount $ns
          fi
        else
          echo "subcmd log not fit for $kind"
        fi
        ;;
      "lf" | "logf")
        if [ "$kind" == "pod" ]; then
          if [ $(hostname) == "$hname" ] && type docker &>/dev/null; then
            docker logs -f $cid $since $amount
          else
            kubectl $kc $context logs -f $resname $cname $since $amount $ns
          fi
        else
          echo "subcmd logf not fit for $kind"
        fi
        ;;
      "i" | "insp" | "inspect")
        if [ "$kind" == "pod" ]; then
          if [ "$(hostname)" == "$hname" ] && type docker &>/dev/null; then
            docker inspect $cid
          else
            execmd "docker inspect $cid" $haddr
          fi
        else
          echo "subcmd inspect not fit for $kind"
        fi
        ;;
      "f" | "gt" | "get")
        kubectl $kc $context get $kind $resname $ns
        ;;
      "s" | "desc" | "describe")
        kubectl $kc $context describe $kind $resname $ns
        ;;
      "wt" | "watch")
        kubectl $kc $context get $kind $resname $ns --watch
        ;;
      "w" | "wide")
        kubectl $kc $context get $kind $resname $ns -o wide
        ;;
      "wl" | "wlabel")
        kubectl $kc $context get $kind $resname $ns -o wide --show-labels
        ;;
      "lb" | "lbo" | "label" | "labelo")
        lbow=""
        if [[ "$subcmd" == "lbo" ]] || [[ "$subcmd" == "labelo" ]]; then
          lbow="--overwrite"
        fi
        kubectl $kc $context label $lbow $kind $resname $args $ns
        ;;
      "y" | "yn" | "yaml")
        if [ $neat -eq 0 ] && [ "$subcmd" != "yn" ]; then
          kubectl $kc $context get $kind $resname $ns -o yaml
        else
          require yq
          kubectl $kc $context get $kind $resname $ns -o yaml | yq d - items.*.status | yq d - items.*.metadata.ownerReferences | yq d - items.*.metadata.managedFields | yq d - 'metadata.annotations."kubectl.kubernetes.io/last-applied-configuration"' | yq d - items.*.metadata.creationTimestamp | yq d - items.*.metadata.generation | yq d - items.*.metadata.generateName | yq d - items.*.metadata.resourceVersion | yq d - items.*.metadata.selfLink | yq d - items.*.metadata.uid | yq d - items.*.spec.template.metadata.creationTimestamp | yq d - status | yq d - metadata.ownerReferences | yq d - metadata.managedFields | yq d - metadata.creationTimestamp | yq d - metadata.generation | yq d - metadata.generateName | yq d - metadata.resourceVersion | yq d - metadata.selfLink | yq d - metadata.uid | yq d - spec.template.metadata.creationTimestamp | grep -v 'progressDeadlineSeconds: 600' | grep -v 'revisionHistoryLimit: 10' | grep -v 'dnsPolicy: ClusterFirst' | grep -v 'dnsConfig: {}' | grep -v 'enableServiceLinks: true' | grep -v 'priority: 0' | grep -v 'restartPolicy: Always' | grep -v 'schedulerName: default-scheduler' | grep -v 'securityContext: {}' | grep -v 'serviceAccountName: default' | grep -v 'terminationGracePeriodSeconds: 30' | grep -v 'terminationMessagePath: /dev/termination-log' | grep -v 'terminationMessagePolicy: File' | grep -v 'imagePullPolicy: IfNotPresent' | grep -v 'resources: {}' | grep -v 'stdin: true' | grep -v 'tty: true'
        fi
        ;;
      "j" | "jn" | "json")
        if [ $neat -eq 0 ] && [ "$subcmd" != "jn" ]; then
          kubectl $kc $context get $kind $resname $ns -o json
        else
          require jq
          kubectl $kc $context get $kind $resname $ns -o json | jq -rM 'del(.status)' | jq -rM 'del(.metadata.ownerReferences)' | jq -rM 'del(.metadata.managedFields)' | jq -rM 'del(.metadata.annotations."kubectl.kubernetes.io/last-applied-configuration")' | jq -rM 'del(.metadata.creationTimestamp)' | jq -rM 'del(.metadata.generation)' | jq -rM 'del(.metadata.generateName)' | jq -rM 'del(.metadata.resourceVersion)' | jq -rM 'del(.metadata.selfLink)' | jq -rM 'del(.metadata.uid)' | jq -rM 'del(.spec.template.metadata.creationTimestamp)' | grep -v '"progressDeadlineSeconds": 600' | grep -v '"revisionHistoryLimit": 10' | grep -v '"dnsPolicy": "ClusterFirst"' | grep -v '"dnsConfig": {}' | grep -v '"enableServiceLinks": true' | grep -v '"priority": 0' | grep -v '"restartPolicy": "Always"' | grep -v '"schedulerName": "default-scheduler"' | grep -v '"securityContext": {}' | grep -v '"serviceAccountName": "default"' | grep -v '"terminationGracePeriodSeconds": 30' | grep -v '"terminationMessagePath": "/dev/termination-log"' | grep -v '"terminationMessagePolicy": "File"' | grep -v '"imagePullPolicy": "IfNotPresent"' | grep -v '"resources": {}' | grep -v '"stdin": true' | grep -v '"tty": true'
        fi
        ;;
      "tp" | "top")
        if [ "$ns" == "--all-namespaces" ]; then
          ns="-n default"
        fi
        if [ "$kind" == "pod" ] || [ "$kind" == "node" ]; then
          kubectl $kc $context top $kind $resname $ns
        fi
        ;;
      "ed" | "edit")
        kubectl $kc $context edit $kind $resname $ns
        ;;
      "p" | "patch")
        kubectl $kc $context patch $kind $resname $ns --patch $args $dryrun $output
        ;;
      "rm" | "del" | "delete")
        isfile="true"
        for fname in ${mandatory[@]}; do
          if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
            isfile="false"
            break
          fi
        done
        if [ "$isfile" == "true" ]; then
          for fname in ${mandatory[@]}; do
            kubectl $kc $context delete -f $fname $dryrun $output
          done
        else
          kubectl $kc $context delete $kind $resname $ns $dryrun $output
        fi
        ;;
      "rmf" | "delf" | "deletef")
        isfile="true"
        for fname in ${mandatory[@]}; do
          if ! [[ $fname =~ .yaml$ ]] && ! [[ $fname =~ .yml$ ]] && ! [[ $fname =~ .json$ ]]; then
            isfile="false"
            break
          fi
        done
        if [ "$isfile" == "true" ]; then
          for fname in ${mandatory[@]}; do
            kubectl $kc $context delete -f $fname --force --grace-period=0 $dryrun $output
          done
        else
          kubectl $kc $context delete $kind $resname $ns --force --grace-period=0 $dryrun $output
          if [ $? -ne 0 ]; then
            kubectl $kc $context patch $kind $resname $ns -p '{"metadata":{"finalizers":[]}}' --type=merge $dryrun $output
          fi
        fi
        ;;
      "e" | "exe" | "exec")
        if [ "$kind" == "pod" ]; then
          kubectl $kc $context exec $resname -c $cname $args $ns
        else
          echo "subcmd exec not fit for $kind"
        fi
        ;;
      "ie" | "iexe" | "iexec")
        if [ $kind == "pod" ]; then
          if [ ${#args[@]} -gt 0 ]; then
            cshell=${args[0]}
          else
            cshell="sh"
          fi
          kubectl $kc $context exec -it $resname -c $cname $cshell $ns
        else
          echo "subcmd iexec not fit for $kind"
        fi
        ;;
      "at" | "attach")
        if [ "$kind" == "pod" ]; then
          kubectl $kc $context attach $resname -c $cname $ns
        else
          echo "subcmd attach not fit for $kind"
        fi
        ;;
      "cp" | "copy")
        if [ "$kind" == "pod" ]; then
          prearg=$(echo "$args" | awk -F ':' '{print $1}')
          sufarg=$(echo "$args" | awk -F ':' '{print $2}')
          if [ "$prearg" == "" ]; then
            prearg="$resname:"$prearg
          else
            sufarg="$resname:"$sufarg
          fi
          kubectl $kc $context cp $prearg$sufarg $ns $dryrun $output
        else
          echo "subcmd copy not fit for $kind"
        fi
        ;;
      "pf" | "forward" | "port-forward")
        if [ "$kind" == "pod" ]; then
          kubectl $kc $context port-forward $resname $args $ns $dryrun $output
        else
          echo "subcmd port-forward not fit for $kind"
        fi
        ;;
      "x" | "dbg" | "debug")
        if [ "$kind" == "pod" ]; then
          if [ ${#args[@]} -gt 0 ]; then
            cshell="$args"
          else
            cshell="sh"
          fi

          cmd="docker run --rm -it $vol --network=container:$cid --pid=container:$cid --ipc=container:$cid $image $cshell $chroot"
          echo "$cmd"

          execmd "$cmd" $haddr
        else
          echo "subcmd debug not fit for $kind"
        fi
        ;;
      *)
        usage
        exit 1
        ;;
      esac
    fi
  fi
}

function require() {
  for dep in $*; do
    if ! type $dep &>/dev/null; then
      echo "$dep required"
      exit 1
    fi
  done
}

function getip() {
  itfs=$(ip -j a | jq -rM '.[].ifname')
  itfs=($itfs)

  ifnets=()
  for ((i = 0; i < ${#itfs[@]}; i++)); do
    itf=${itfs[$i]}
    itfi=$(ip -j a show dev $itf)
    status=$(echo $itfi | jq -rM '.[].operstate')
    ether=$(echo $itfi | jq -rM '.[].address')
    if [ -z "$ether" ]; then
      ether="NA"
    fi
    mtu=$(echo $itfi | jq -rM '.[].mtu')
    inet=$(echo $itfi | jq -rM '.[].addr_info[]|select(.family=="inet")|.local')
    inetprefix=$(echo $itfi | jq -rM '.[].addr_info[]|select(.family=="inet")|.prefixlen')
    inetdyn=$(echo $itfi | jq -rM '.[].addr_info[]|select(.family=="inet")|.dynamic')
    if [ -z "$inetdyn" ]; then
      inetassign=""
    else
      if [ "$inetdyn" == "true" ]; then
        inetassign="D"
      else
        inetassing="S"
      fi
    fi
    if [ -n "$inetprefix" ]; then
      inet=$inet/$inetprefix
    fi
    if [ -n "$inetassign" ]; then
      inet=$inet"#$inetassign"
    fi
    if [ -z "$inet" ]; then
      inet="NA"
    fi
    inet6=$(echo $itfi | jq -rM '.[].addr_info[]|select(.family=="inet6")|.local')
    inet6prefix=$(echo $itfi | jq -rM '.[].addr_info[]|select(.family=="inet6")|.prefixlen')
    inet6dyn=$(echo $itfi | jq -rM '.[].addr_info[]|select(.family=="inet6")|.dynamic')
    if [ -z "$inet6dyn" ]; then
      inet6assign=""
    else
      if [ "$inet6dyn" == "true" ]; then
        inet6assign="D"
      else
        inet6assing="S"
      fi
    fi
    if [ -n "$inet6prefix" ]; then
      inet6=$inet6/$inet6prefix
    fi
    if [ -n "$inet6assign" ]; then
      inet6=$inet6"#$inet6assign"
    fi
    if [ -z "$inet6" ]; then
      inet6="NA"
    fi
    item="$itf: $inet $inet6 $ether $mtu $status"
    ifnets[$i]="$item"
  done

  for ((i = 0; i < ${#ifnets[@]}; i++)); do
    if [ "$1" == "ipp" ]; then
      echo ${ifnets[$i]} | awk '{printf "%-20s\t%-20s\t%-30s\t%-18s\t%-6s\t%-8s\n", $1, $2, $3, $4, $5, $6}' | grep -iE '^(en|wl|ww|eth)' | grep "$2"
    elif [ "$1" == "ipa" ]; then
      echo ${ifnets[$i]} | awk '{printf "%-20s\t%-20s\t%-30s\t%-18s\t%-6s\t%-8s\n", $1, $2, $3, $4, $5, $6}' | grep "$2"
    else
      echo ${ifnets[$i]} | awk '{printf "%-20s\t%-20s\t%-30s\t%-18s\t%-6s\t%-8s\n", $1, $2, $3, $4, $5, $6}' | grep "$1"
    fi
  done
}

function pping() {
  for ipaddr in $@; do
    if [ $(echo "$ipaddr" | tr -cd 1 | wc -c) -eq 2 ]; then
      ipd=$ipaddr
      ipr="1-254"
    else
      ipd=${ipaddr%.*}
      ipr=${ipaddr##*.}
    fi

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      if [ ${cip##*.} -le 9 ]; then
        sip="$cip  "
      elif [ ${cip##*.} -le 99 ]; then
        sip="$cip "
      else
        sip="$cip"
      fi
      if ping -c 1 -w 1 $cip &>/dev/null; then
        echo -e "\e[1;32m $sip is up \e[0m"
      else
        echo -e "\e[1;31m $sip is down \e[0m"
      fi
    done
  done
}

function checkimage() {
    line="$1"
    regurl="$2"
    reguser="$3"
    regpasswd="$4"

    repo=${line%%:*}
    tag=${line##*:}
    if [ "$repo" == "$tag" ] && [[ ! "$line" =~ ":" ]]; then
        tag="latest"
    fi
    project=${repo%%/*}
    rname=${repo#*/}
    if [ "$project" == "$rname" ] && [[ ! "$line" =~ "/" ]]; then
        project="library"
    fi
    
    echo -ne "[ .... ] checking $project/$rname:$tag\r"
    resp=$(curl -Gks -u $reguser:$regpasswd "$regurl/api/v2.0/projects/$project/repositories/$rname/artifacts/$tag/tags")
    if [[ "$resp" =~ "NOT_FOUND" ]]; then
        echo -e "[\033[1;31m FAIL \033[0m]"
    else
        echo -e "[\033[1;32m SUCC \033[0m]"
    fi
}

function dockerpush() {
  require docker
  # lrepo=${1%/*}
  limg=${1##*/}
  rrepo=${2%/*}
  rlib=${2#*/}

  if [ "$rlib" == "" ] || [ "$rlib" == "$rrepo" ]; then
    if [[ "$rrepo" =~ "." ]]; then
      rlib="library"
    else
      rlib=$rrepo
      rrepo="docker.io"
    fi
  fi

  docker tag $1 $rrepo/$rlib/$limg
  docker push $rrepo/$rlib/$limg
  docker rmi -f $rrepo/$rlib/$limg
}

function docmd() {
  eval "$*"
}

function lexecmd() {
  ecmd=$1
  ipaddr=$2

  if [ "$ipaddr" == "" ]; then
    docmd $ecmd
  else
    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "============================== $cip =============================="
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd $ecmd $iuser$cip
      else
        docmd $ecmd $iuser$cip
      fi
    done
  fi
}

function execmd() {
  ecmd=$1
  ipaddr=$2

  if [ "$ipaddr" == "" ]; then
    docmd $ecmd
  else
    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iport=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$port" ]; then
      iport="-p $port"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "============================== $cip =============================="
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd ssh -t $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout $iuser$cip "$ecmd"
      else
        ssh -t $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout $iuser$cip "$ecmd"
      fi
    done
  fi
}

function batch() {
  pw=""
  if [ -z "$port" ]; then
    port="22"
  fi
  if [ -z "$user" ]; then
    user="root"
  fi
  if [ -n "$passwd" ]; then
    if ! type sshpass &>/dev/null; then
      echo "sshpass required"
      exit 1
    fi
    pw="sshpass -p $passwd"
  fi

  local mode=$1
  local host=$2
  local cmd=$3
  
  ipd=${host%.*}
  ipr=${host##*.}

  ipstart=$ipr
  ipend=$ipr

  if [[ "$ipr" =~ "-" ]]; then
    ipstart=${ipr%-*}
    ipend=${ipr##*-}
  fi
  
  for ((i = $ipstart; i <= $ipend; i++)); do
    if [ $ipd == $ipr ]; then
      cip=$ipd
    else
      cip=$ipd.$i
    fi

    echo "============================== $cip =============================="
    case $mode in
    ping)
      if /bin/ping -c 1 -w 1 $cip &>/dev/null; then
        echo "$cip [succ]"
      else
        echo "$cip [fail]"
      fi
      ;;
    shell)
      $pw ssh -p $port $user@$cip $cmd
      ;;
    script)
      #$pw ssh -p $port $user@$cip "bash $cmd"
      $pw ssh -p $port $user@$cip 'bash -s' < $cmd
      ;;
    copy)
      local src=`echo $cmd | awk '{print $1}'`
      local dest=`echo $cmd | awk '{print $2}'`
      $pw scp -r -P $port $src $user@$cip:$dest
      ;;
    fetch)
      local src=`echo $cmd | awk '{print $1}'`
      local dest=`echo $cmd | awk '{print $2}'`
      $pw scp -r -P $port $user@$cip:$src $dest
      ;;
    template)
      local src=`echo $cmd | awk '{print $1}'`
      local old=`echo $cmd | awk '{print $2}'`
      local new=`echo $cmd | awk '{print $3}'`
      $pw ssh -p $port $user@$cip "sed -i 's/$old/$new/g' $src"
      ;;
    *)
      echo '
USAGE:
  COMMAND:
    kude bat -u [user] -s [password] -p [port] <mode> <hosts> <args>
  MODES:
    ping: ping hosts
    shell: run command on hosts
    script: execute script on hosts
    copy: copy local files to hosts
    fetch: fetch files on hosts to local
    template: replace string for the file on hosts
  EXAMPLES:
    kude bat ping "127.0.0.1 196.168.0.1-10"
    kude bat ping "${array[*]}"
    kude bat -u root -p 22 shell "${array[*]}" "ps"
    kude bat -s password script "${array[*]}" "run.sh"
    kude bat copy "${array[*]}" "/home/demo/run.sh /root/"
    kude bat template "${array[*]}" "/home/demo/run.sh foo bar"
    '
      exit 1
      ;;
    esac
  done
}

function remotecp() {
  paths=$1
  ipaddr=$2

  if [ "$paths" == "" ] || [ "$ipaddr" == "" ]; then
    return
  else
    #     if [ -z "$user" ]; then
    #       user="root"
    #     fi
    #     if [ -z "$passwd" ]; then
    #       passwd="root"
    #     fi

    lpath=${paths%:*}
    rpath=${paths##*:}

    ipd=${ipaddr%.*}
    ipr=${ipaddr##*.}

    ipstart=$ipr
    ipend=$ipr

    if [[ "$ipr" =~ "-" ]]; then
      ipstart=${ipr%-*}
      ipend=${ipr##*-}
    fi

    ipasswd=""
    iport=""
    iuser=""
    if [ -n "$passwd" ]; then
      ipasswd="-p $passwd"
    fi
    if [ -n "$port" ]; then
      iport="-P $port"
    fi
    if [ -n "$user" ]; then
      iuser="$user@"
    fi

    for ((i = $ipstart; i <= $ipend; i++)); do
      if [ $ipd == $ipr ]; then
        cip=$ipd
      else
        cip=$ipd.$i
      fi
      echo "============================== $cip =============================="
      if [ -n "$passwd" ] && type sshpass &>/dev/null; then
        sshpass $ipasswd scp $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout -r $lpath $iuser$cip:$rpath
      else
        scp $iport -o StrictHostKeyChecking=no -o ConnectTimeout=$timeout -r $lpath $iuser$cip:$rpath
      fi
    done
  fi
}

function optimize() {
  # OS调优
  echo "
    net.bridge.bridge-nf-call-ip6tables=1
    net.bridge.bridge-nf-call-iptables=1
    net.ipv4.ip_forward=1
    net.ipv4.conf.all.forwarding=1
    net.ipv4.neigh.default.gc_thresh1=128
    net.ipv4.neigh.default.gc_thresh2=6144
    net.ipv4.neigh.default.gc_thresh3=8192
    net.ipv4.neigh.default.gc_interval=60
    # 检查一次相邻层记录的有效性的周期。当相邻层记录失效时，将在给它发送数据前，再解析一次。默认值：60 秒。
    net.ipv4.neigh.default.gc_stale_time=120

    # 参考 https://github.com/prometheus/node_exporter#disabled-by-default
    kernel.perf_event_paranoid=-1

    # softlockup_panic如果为 1，在出现 panic 后将导致系统重启
    kernel.softlockup_panic=0
    kernel.watchdog_thresh=30
    # 系统中所有进程能够同时打开的文件句柄数量
    fs.file-max=2097152
    # 设置每个用户可以运行的inotifywait或inotifywatch命令的进程数。
    fs.inotify.max_user_instances=8192
    # inotify用于监控文件系统事件，该文件中的值为调用inotify_init函数时分配给inotify队列的事件数目的最大值，超出这个值得事件被丢弃，但会触发IN_Q_OVERFLOW事件，文件系统变化越频繁，这个值就应该越大
    fs.inotify.max_queued_events=16384
    # IO复用epoll监听文件句柄的数量最大值
    fs.inotify.max_user_watches=524288

    # 是否禁用ipv6：0：不禁用，1：禁用
    #net.ipv6.conf.all.disable_ipv6=0
    #net.ipv6.conf.default.disable_ipv6=0
    #net.ipv6.conf.lo.disable_ipv6=0

    kernel.yama.ptrace_scope=0
    vm.swappiness=0

    # 可以控制core文件的文件名中是否添加pid作为扩展。
    kernel.core_uses_pid=1

    # Promote secondary addresses when the primary address is removed
    # 0：当接口的主IP地址被移除时，删除所有次IP地址
    # 1：当接口的主IP地址被移除时，将次IP地址提升为主IP地址
    net.ipv4.conf.default.promote_secondaries=1
    net.ipv4.conf.all.promote_secondaries=1

    # 源路由验证
    # see details in https://help.aliyun.com/knowledge_detail/39428.html
    net.ipv4.conf.all.rp_filter=0
    net.ipv4.conf.default.rp_filter=0
    net.ipv4.conf.default.arp_announce = 2
    net.ipv4.conf.lo.arp_announce=2
    net.ipv4.conf.all.arp_announce=2

    # see details in https://help.aliyun.com/knowledge_detail/41334.html
    net.ipv4.tcp_syncookies=1
    net.ipv4.tcp_fin_timeout=30
    net.ipv4.tcp_synack_retries=2
    net.ipv4.tcp_max_syn_backlog=8096
    kernel.sysrq=1
    net.ipv4.tcp_tw_recycle=0

    " >>/etc/sysctl.conf

  sysctl -p

  # nofile优化
  cat >>/etc/security/limits.conf <<EOF
    * soft nofile 65535
    * hard nofile 65536
EOF

  # docker优化
  touch /etc/docker/daemon.json
  cat >/etc/docker/daemon.json <<EOF
    {
        "oom-score-adjust": -1000,
        "log-driver": "json-file",
        "log-opts": {
        "max-size": "100m",
        "max-file": "3"
        },
        "max-concurrent-downloads": 10,
        "max-concurrent-uploads": 10,
        "insecure-registries": ["hub.ebcpaas.com"],
        "registry-mirrors": ["https://hub.ebcpaas.com"],
        "storage-driver": "overlay2",
        "storage-opts": [
        "overlay2.override_kernel_check=true"
        ]
    }
EOF
  systemctl daemon-reload && systemctl restart docker

  # etcd优化
  if pgrep etcd &>/dev/null; then
    # cpu优先级
    renice -n -20 -p $(pgrep etcd)
    # disk优先级
    ionice -c2 -n0 -p $(pgrep etcd)
  fi
  # network优先级
  NETWORK_INTERFACE=eth0
  tc qdisc add dev ${NETWORK_INTERFACE} root handle 1: prio bands 3
  tc filter add dev ${NETWORK_INTERFACE} parent 1: protocol ip prio 1 u32 match ip sport 2380 0xffff flowid 1:1
  tc filter add dev ${NETWORK_INTERFACE} parent 1: protocol ip prio 1 u32 match ip dport 2380 0xffff flowid 1:1
  tc filter add dev ${NETWORK_INTERFACE} parent 1: protocol ip prio 2 u32 match ip sport 2739 0xffff flowid 1:1
  tc filter add dev ${NETWORK_INTERFACE} parent 1: protocol ip prio 2 u32 match ip dport 2739 0xffff flowid 1:1
}

function genssl() {
  case "$1" in
  -h | --help)
    gensslhelp
    exit
    ;;
  esac

  if [[ $1 == '' ]]; then
    gensslhelp
    exit
  fi

  CMDOPTS="$*"
  for OPTS in $CMDOPTS; do
    key=$(echo ${OPTS} | awk -F"=" '{print $1}')
    value=$(echo ${OPTS} | awk -F"=" '{print $2}')
    case "$key" in
    --ssl-domain) SSL_DOMAIN=$value ;;
    --ssl-trusted-ip) SSL_TRUSTED_IP=$value ;;
    --ssl-trusted-domain) SSL_TRUSTED_DOMAIN=$value ;;
    --ssl-size) SSL_SIZE=$value ;;
    --ssl-date) SSL_DATE=$value ;;
    --ca-date) CA_DATE=$value ;;
    --ssl-cn) CN=$value ;;
    --ca-reuse) CA_REUSE=$value ;;
    --ca-key) CA_KEY=$value ;;
    --ca-cert) CA_CERT=$value ;;
    esac
  done

  # CA相关配置
  CA_DATE=${CA_DATE:-3650}
  CA_KEY=${CA_KEY:-cakey.pem}
  CA_CERT=${CA_CERT:-cacerts.pem}
  CA_DOMAIN=localhost
  CA_REUSE=${CA_REUSE:-false}

  # ssl相关配置
  SSL_CONFIG=${SSL_CONFIG:-$PWD/openssl.cnf}
  SSL_DOMAIN=${SSL_DOMAIN:-localhost}
  SSL_DATE=${SSL_DATE:-3650}
  SSL_SIZE=${SSL_SIZE:-2048}

  ## 国家代码(2个字母的代号),默认CN;
  CN=${CN:-CN}

  SSL_KEY=$SSL_DOMAIN.key
  SSL_CSR=$SSL_DOMAIN.csr
  SSL_CERT=$SSL_DOMAIN.crt

  echo -e "\033[32m ---------------------------- \033[0m"
  echo -e "\033[32m       | 生成 SSL Cert |       \033[0m"
  echo -e "\033[32m ---------------------------- \033[0m"

  if [[ -e ./${CA_KEY} ]]; then
    if [[ ${CA_REUSE} == true ]]; then
      echo -e "\033[32m ====> 1. 复用已存在CA私钥 \033[0m"
    else
      echo -e "\033[32m ====> 1. 发现已存在CA私钥，备份"${CA_KEY}"为"${CA_KEY}"-bak，然后重新创建 \033[0m"
      mv ${CA_KEY} "${CA_KEY}"-bak
      openssl genrsa -out ${CA_KEY} ${SSL_SIZE}
    fi
  else
    echo -e "\033[32m ====> 1. 生成新的CA私钥 ${CA_KEY} \033[0m"
    openssl genrsa -out ${CA_KEY} ${SSL_SIZE}
  fi

  if [[ -e ./${CA_CERT} ]]; then
    if [[ ${CA_REUSE} == true ]]; then
      echo -e "\033[32m ====> 1. 复用已存在CA证书 \033[0m"
    else
      echo -e "\033[32m ====> 2. 发现已存在CA证书，先备份"${CA_CERT}"为"${CA_CERT}"-bak，然后重新创建 \033[0m"
      mv ${CA_CERT} "${CA_CERT}"-bak
      openssl req -x509 -sha256 -new -nodes -key ${CA_KEY} -days ${CA_DATE} -out ${CA_CERT} -subj "/C=${CN}/CN=${CA_DOMAIN}"
    fi
  else
    echo -e "\033[32m ====> 2. 生成新的CA证书 ${CA_CERT} \033[0m"
    openssl req -x509 -sha256 -new -nodes -key ${CA_KEY} -days ${CA_DATE} -out ${CA_CERT} -subj "/C=${CN}/CN=${CA_DOMAIN}"
  fi

  echo -e "\033[32m ====> 3. 生成Openssl配置文件 ${SSL_CONFIG} \033[0m"
  cat >${SSL_CONFIG} <<EOM
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, serverAuth
EOM

  if [[ -n ${SSL_TRUSTED_IP} || -n ${SSL_TRUSTED_DOMAIN} ]]; then
    cat >>${SSL_CONFIG} <<EOM
subjectAltName = @alt_names
[alt_names]
EOM
    IFS=","
    dns=(${SSL_TRUSTED_DOMAIN})
    dns+=(${SSL_DOMAIN})
    for i in "${!dns[@]}"; do
      echo DNS.$((i + 1)) = ${dns[$i]} >>${SSL_CONFIG}
    done

    if [[ -n ${SSL_TRUSTED_IP} ]]; then
      ip=(${SSL_TRUSTED_IP})
      for i in "${!ip[@]}"; do
        echo IP.$((i + 1)) = ${ip[$i]} >>${SSL_CONFIG}
      done
    fi
  fi

  echo -e "\033[32m ====> 4. 生成服务SSL KEY ${SSL_KEY} \033[0m"
  openssl genrsa -out ${SSL_KEY} ${SSL_SIZE}

  echo -e "\033[32m ====> 5. 生成服务SSL CSR ${SSL_CSR} \033[0m"
  openssl req -sha256 -new -key ${SSL_KEY} -out ${SSL_CSR} -subj "/C=${CN}/CN=${SSL_DOMAIN}" -config ${SSL_CONFIG}

  echo -e "\033[32m ====> 6. 生成服务SSL CERT ${SSL_CERT} \033[0m"
  openssl x509 -sha256 -req -in ${SSL_CSR} -CA ${CA_CERT} \
    -CAkey ${CA_KEY} -CAcreateserial -out ${SSL_CERT} \
    -days ${SSL_DATE} -extensions v3_req \
    -extfile ${SSL_CONFIG}

  echo -e "\033[32m ====> 7. 证书制作完成 \033[0m"
  echo
  echo -e "\033[32m ====> 8. 以YAML格式输出结果 \033[0m"
  echo "----------------------------------------------------------"
  echo "ca_key: |"
  cat $CA_KEY | sed 's/^/  /'
  echo
  echo "ca_cert: |"
  cat $CA_CERT | sed 's/^/  /'
  echo
  echo "ssl_key: |"
  cat $SSL_KEY | sed 's/^/  /'
  echo
  echo "ssl_csr: |"
  cat $SSL_CSR | sed 's/^/  /'
  echo
  echo "ssl_cert: |"
  cat $SSL_CERT | sed 's/^/  /'
  echo

  echo -e "\033[32m ====> 9. 附加CA证书到Cert文件 \033[0m"
  cat ${CA_CERT} >>${SSL_CERT}
  echo "ssl_cert: |"
  cat $SSL_CERT | sed 's/^/  /'
  echo

  echo -e "\033[32m ====> 10. 重命名服务证书 \033[0m"
  echo "cp ${SSL_DOMAIN}.key tls.key"
  cp ${SSL_DOMAIN}.key tls.key
  echo "cp ${SSL_DOMAIN}.crt tls.crt"
  cp ${SSL_DOMAIN}.crt tls.crt
}

function parse_yaml() {
    local yaml_file=$1
    local prefix=$2
    local s
    local w
    local fs

    s='[[:space:]]*'
    w='[a-zA-Z0-9_.-]*'
    fs="$(echo @ | tr @ '\034')"

    (
        sed -e '/- [^\“]'"[^\']"'.*: /s|\([ ]*\)- \([[:space:]]*\)|\1-\'$'\n''  \1\2|g' |
            sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/[[:space:]]*$//g;' \
                -e 's/\$/\\\$/g' \
                -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
                -e "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
                -e "s|^\($s\)\($w\)${s}[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |
            awk -F"$fs" '{
            indent = length($1)/2;
            if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
            vname[indent] = $2;
            for (i in vname) {if (i > indent) {delete vname[i]}}
                if (length($3) > 0) {
                    vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
                    printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1], $3);
                }
            }' |
            sed -e 's/_=/+=/g' |
            awk 'BEGIN {
                FS="=";
                OFS="="
            }
            /(-|\.).*=/ {
                gsub("-|\\.", "_", $1)
            }
            { print }'
    ) <"$yaml_file"
}

function unset_variables() {
    # Pulls out the variable names and unsets them.
    #shellcheck disable=SC2048,SC2206 #Permit variables without quotes
    local variable_string=($*)
    unset variables
    variables=()
    for variable in "${variable_string[@]}"; do
        tmpvar=$(echo "$variable" | grep '=' | sed 's/=.*//' | sed 's/+.*//')
        variables+=("$tmpvar")
    done
    for variable in "${variables[@]}"; do
        if [ -n "$variable" ]; then
            unset "$variable"
        fi
    done
}

function create_variables() {
    local yaml_file="$1"
    local prefix="$2"
    local yaml_string
    yaml_string="$(parse_yaml "$yaml_file" "$prefix")"
    unset_variables "${yaml_string}"
    eval "${yaml_string}"
}

function javadump() {
  DUMP_PIDS=$(ps --no-heading -C java -f --width 1000 | awk '{print $2}')
  if [ -z "$DUMP_PIDS" ]; then
    echo "The server $HOST_NAME is not started!"
    exit 1
  fi

  DUMP_ROOT=~/dump
  if [ ! -d $DUMP_ROOT ]; then
    mkdir $DUMP_ROOT
  fi

  DUMP_DATE=$(date +%Y%m%d%H%M%S)
  DUMP_DIR=$DUMP_ROOT/dump-$DUMP_DATE
  if [ ! -d $DUMP_DIR ]; then
    mkdir $DUMP_DIR
  fi

  for PID in $DUMP_PIDS; do
    #Full thread dump 用来查线程占用，死锁等问题
    $JAVA_HOME/bin/jstack $PID >$DUMP_DIR/jstack-$PID.dump 2>&1
    echo -e ".\c"
    #打印出一个给定的Java进程、Java core文件或远程Debug服务器的Java配置信息，具体包括Java系统属性和JVM命令行参数。
    $JAVA_HOME/bin/jinfo $PID >$DUMP_DIR/jinfo-$PID.dump 2>&1
    echo -e ".\c"
    #jstat能够动态打印jvm(Java Virtual Machine Statistics Monitoring Tool)的相关统计信息。如young gc执行的次数、full gc执行的次数，各个内存分区的空间大小和可使用量等信息。
    $JAVA_HOME/bin/jstat -gcutil $PID >$DUMP_DIR/jstat-gcutil-$PID.dump 2>&1
    echo -e ".\c"
    $JAVA_HOME/bin/jstat -gccapacity $PID >$DUMP_DIR/jstat-gccapacity-$PID.dump 2>&1
    echo -e ".\c"
    #未指定选项时，jmap打印共享对象的映射。对每个目标VM加载的共享对象，其起始地址、映射大小及共享对象文件的完整路径将被打印出来，
    $JAVA_HOME/bin/jmap $PID >$DUMP_DIR/jmap-$PID.dump 2>&1
    echo -e ".\c"
    #-heap打印堆情况的概要信息，包括堆配置，各堆空间的容量、已使用和空闲情况
    $JAVA_HOME/bin/jmap -heap $PID >$DUMP_DIR/jmap-heap-$PID.dump 2>&1
    echo -e ".\c"
    #-dump将jvm的堆中内存信息输出到一个文件中,然后可以通过eclipse memory analyzer进行分析
    #注意：这个jmap使用的时候jvm是处在假死状态的，只能在服务瘫痪的时候为了解决问题来使用，否则会造成服务中断。
    $JAVA_HOME/bin/jmap -dump:format=b,file=$DUMP_DIR/jmap-dump-$PID.dump $PID 2>&1
    echo -e ".\c"
    #显示被进程打开的文件信息
    if [ -r /usr/sbin/lsof ]; then
      /usr/sbin/lsof -p $PID >$DUMP_DIR/lsof-$PID.dump
      echo -e ".\c"
    fi
  done
  #主要负责收集、汇报与存储系统运行信息的。
  if [ -r /usr/bin/sar ]; then
    /usr/bin/sar >$DUMP_DIR/sar.dump
    echo -e ".\c"
  fi
  #主要负责收集、汇报与存储系统运行信息的。
  if [ -r /usr/bin/uptime ]; then
    /usr/bin/uptime >$DUMP_DIR/uptime.dump
    echo -e ".\c"
  fi
  #内存查看
  if [ -r /usr/bin/free ]; then
    /usr/bin/free -t >$DUMP_DIR/free.dump
    echo -e ".\c"
  fi
  #可以得到关于进程、内存、内存分页、堵塞IO、traps及CPU活动的信息。
  if [ -r /usr/bin/vmstat ]; then
    /usr/bin/vmstat >$DUMP_DIR/vmstat.dump
    echo -e ".\c"
  fi
  #报告与CPU相关的一些统计信息
  if [ -r /usr/bin/mpstat ]; then
    /usr/bin/mpstat >$DUMP_DIR/mpstat.dump
    echo -e ".\c"
  fi
  #报告与IO相关的一些统计信息
  if [ -r /usr/bin/iostat ]; then
    /usr/bin/iostat >$DUMP_DIR/iostat.dump
    echo -e ".\c"
  fi
  #报告与网络相关的一些统计信息
  if [ -r /bin/netstat ]; then
    /bin/netstat >$DUMP_DIR/netstat.dump
    echo -e ".\c"
  fi
  echo "OK!"
}

function formatOutput() {
  #### usage ####
  # regions=("NAME;AGE;SCORE" "Tom Li;14;89" "Lucy;13;;" "Jack;;92")
  ## regions[0]="NAME;AGE;SCORE"
  ## regions[1]="Tom Li;14;89"
  ## regions[2]="Lucy;13;;"
  ## regions[3]="Jack;;92"
  # formatOutput "${regions[@]}"

  sep="#"
  function append_cell() {
    #对表格追加单元格
    #append_cell col0 "col 1" ""
    #append_cell col3
    local i
    for i in "$@"; do
      line+="|$i${sep}"
    done
  }
  function check_line() {
    if [ -n "$line" ]; then
      c_c=$(echo $line | tr -cd "${sep}" | wc -c)
      difference=$((${column_count} - ${c_c}))
      if [ $difference -gt 0 ]; then
        line+=$(seq -s " " $difference | sed -r s/[0-9]\+/\|${sep}/g | sed -r s/${sep}\ /${sep}/g)
      fi
      content+="${line}|\n"
    fi
  }

  function append_line() {
    check_line
    line=""
    local items=("$@")
    for ((i = 0; i < ${#items[@]}; i++)); do
      line+="|${items[$i]}${sep}"
    done
    check_line
    line=""
  }

  function segmentation() {
    local seg=""
    local i
    for i in $(seq $column_count); do
      seg+="+${sep}"
    done
    seg+="${sep}+\n"
    echo $seg
  }

  function set_title() {
    #表格标头，以空格分割，包含空格的字符串用引号，如
    #set_title Column_0 "Column 1" "" Column3
    [ -n "$title" ] && echo "Warring:表头已经定义过,重写表头和内容"
    column_count=0
    title=""
    local items=("$@")
    for ((i = 0; i < ${#items[@]}; i++)); do
      title+="|${items[$i]}${sep}"
      let column_count++
    done
    title+="|\n"
    seg=$(segmentation)
    title="${seg}${title}${seg}"
    content=""
  }

  function output_table() {
    if [ ! -n "${title}" ]; then
      echo "未设置表头，退出" && return 1
    fi
    append_line
    table="${title}${content}$(segmentation)"
    echo -e $table | column -s "${sep}" -t | awk '{if($0 ~ /^+/){gsub(" ","-",$0);print $0}else{gsub("\\(\\*\\)","\033[31m(*)\033[0m",$0);print $0}}'
  }

  local lns=("$@")
  for ((ii = 0; ii < ${#lns[@]}; ii++)); do
    local ln="${lns[$ii]}"
    declare -a arr
    IFS=';' read -ra ADDR <<<"$ln"
    for k in "${ADDR[@]}"; do
      arr[${#arr[*]}]="$k"
    done
    if [ $ii -eq 0 ]; then
      set_title "${arr[@]}"
    else
      append_line "${arr[@]}"
    fi
    unset arr
  done
  output_table
}

function fileType() {
  ext=$(echo "${1##*.}" | tr 'A-Z' 'a-z')
  case "$ext" in
  "ico" | "png" | "jpg" | "jpeg" | "bmp" | "gif" | "tiff" | "svg" | "webp" | "tif")
    echo "image"
    ;;
  "mp3" | "mp2" | "m4a" | "wav" | "amr" | "awb" | "wma" | "ogg" | "mid" | "xmf" | "rtttl" | "smf" | "imy" | "ape" | "flac" | "aiff" | "aac" | "cd")
    echo "audio"
    ;;
  "mp4" | "m4v" | "m3u8" | "3gp" | "3gpp" | "3g2" | "3gpp2" | "wmv" | "mkv" | "asf" | "asx" | "rm" | "rmvb" | "mov" | "avi" | "flv" | "vob" | "mpeg" | "dv" | "divx" | "xvid" | "mod")
    echo "video"
    ;;
  *)
    echo "doc"
    ;;
  esac
}

function Debug() {
  [ "$DEBUG" == "on" ] && $@ || :
}

function aliasKind() {
  kind=$1
  if [ "$kind" == "dep" ]; then
    kind="deploy"
  elif [ "$kind" == "np" ]; then
    kind="networkpolicy"
  elif [ "$kind" == "lr" ]; then
    kind="limitrange"
  elif [ "$kind" == "rq" ]; then
    kind="resourcequota"
  elif [ "$kind" == "rb" ]; then
    kind="rolebinding"
  elif [ "$kind" == "cr" ]; then
    kind="clusterrole"
  elif [ "$kind" == "crb" ]; then
    kind="clusterrolebinding"
  elif [ "$kind" == "sec" ]; then
    kind="secret"
  elif [ "$kind" == "pm" ]; then
    kind="prometheus"
  elif [ "$kind" == "pr" ]; then
    kind="prometheusrule"
  elif [ "$kind" == "sm" ]; then
    kind="servicemonitor"
  elif [ "$kind" == "am" ]; then
    kind="alertmanager"
  elif [ "$kind" == "pj" ]; then
    kind="project"
  elif [ "$kind" == "ct" ]; then
    kind="cluster"
  elif [ "$kind" == "app" ]; then
    kind="application"
  elif [ "$kind" == "crt" ] || [ "$kind" == "cert" ]; then
    kind="certificate"
  elif [ "$kind" == "vwc" ]; then
    kind="validatingwebhookconfigurations"
  elif [ "$kind" == "mwc" ]; then
    kind="mutatingwebhookconfigurations"
  fi
  echo $kind
}

function genKindConfig() {
  echo "
kind: Cluster
apiVersion: kind.sigs.k8s.io/v1alpha3
kubeadmConfigPatches:
- |
  apiVersion: kubeadm.k8s.io/v1beta1
  kind: ClusterConfiguration
  metadata:
    name: config
  networking:
    serviceSubnet: 10.0.0.0/16
  imageRepository: gcr.mirrors.ustc.edu.cn/google_containers
  nodeRegistration:
    kubeletExtraArgs:
      pod-infra-container-image: gcr.mirrors.ustc.edu.cn/google_containers/pause:3.1
- |
  apiVersion: kubeadm.k8s.io/v1beta1
  kind: InitConfiguration
  metadata:
    name: config
  networking:
    serviceSubnet: 10.0.0.0/16
  imageRepository: gcr.mirrors.ustc.edu.cn/google_containers
nodes:
- role: control-plane

# kind create cluster --name kind --config kind.yaml
  " >/tmp/kind.yaml
}

function printSample() {
  local dockerSample="
FROM alpine:latest

LABEL maintainer='xshrim@yeah.net'

RUN set -ex && apk update && apk upgrade && apk add --no-cache bash

WORKDIR /root/

ADD motd /etc/motd
COPY static /root/static

#RUN mkdir /lib64 && ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2 && apk add -U util-linux && apk add -U tzdata && cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 解决go语言程序无法在alpine执行的问题和syslog不支持udp的问题和时区问题

EXPOSE 22 445/tcp

CMD [\"sh\",\"/root/run.sh\"]
"

  local secretSample="
apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
  namespace: awesomeapps
data:
  .dockerconfigjson: UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==
type: kubernetes.io/dockerconfigjson
"

  local configmapSample="
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-config
  namespace: default
data:
  my.yaml: |
    name: tom
    light.weight: baby
    gym: muscle
"

  local rbacSample="
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: role-grantor
rules:
- apiGroups: [\"rbac.authorization.k8s.io\"]
  resources: [\"rolebindings\"]
  verbs: [\"create\"]
- apiGroups: [\"rbac.authorization.k8s.io\"]
  resources: [\"clusterroles\"]
  verbs: [\"bind\"]
  resourceNames: [\"admin\",\"edit\",\"view\"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: role-grantor-binding
  namespace: user-1-namespace
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: role-grantor
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: ServiceAccount
  name: grantor
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    foo: bar
  name: grantor
  namespace: default
"

  local storageSample="
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nas
parameters:
  archiveOnDelete: \"true\"
provisioner: cluster.local/nas-client-provisioner
reclaimPolicy: Delete
volumeBindingMode: Immediate
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfs-pv
  labels:
    release: stable
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteMany
  persistentVolumeReclaimPolicy: Recycle
  mountOptions:
  - hard
  - nfsvers=4.1
  nfs:
    server: 10.10.10.10
    path: /nas
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-pvc
spec:
  accessModes:
  - ReadWriteMany
  selector:
    matchLabels:
      release: stable
    matchExpressions:
    - {key: environment, operator: In, values: [dev]}
  storageClassName: manual
  resources:
    requests:
      storage: 1Gi
"

  local serviceSample="
apiVersion: v1
kind: Service
metadata:
  name: websvc
  namespace: default
  labels:
    run: nginx
spec:
  type: clusterIP
  clusterIP: None
  ports:
  - name: webport
    port: 80
    protocol: TCP
    targetPort: 80
    nodePort: 30300
  selector:
    run: nginx
---
apiVersion: v1
kind: Endpoints
metadata:
  name: websvc
subsets:
- addresses:
  - ip: 25.10.10.10
  ports:
  - port: 80
"

  local ingressSample="
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/backend-protocol: HTTPS
    nginx.ingress.kubernetes.io/proxy-body-size: 1000M
    nginx.ingress.kubernetes.io/ssl-redirect: \"false\"
    nginx.ingress.kubernetes.io/rewrite-target: /$1
    nginx.ingress.kubernetes.io/cors-allow-headers: DNT,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,Accept,Origin,Referer
    nginx.ingress.kubernetes.io/cors-allow-methods: GET, PUT, POST, DELETE, PATCH
    nginx.ingress.kubernetes.io/enable-cors: \"true\"
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers \"X-Frame-Options: ALLOW-FROM *\";
  name: kubernetes
  namespace: default
spec:
  tls:
    - hosts:
        - foo.bar.com
      secretName: ingress-tls
  rules:
    - host: foo.bar.com
      http:
        paths:
          - backend:
              serviceName: kubernetes
              servicePort: 443
            path: /region/(.*)
"

  local podSample="
apiVersion: v1
kind: Pod
metadata:
  name: xo
  namespace: default
  labels:
    app: xo
  annotations:
    alpha.istio.io/sidecar: ignore
spec:
  nodeSelector:
    disk: ssd
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/project
            operator: In
            values:
            - demo
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: security
            operator: In
            values:
            - S1
        topologyKey: failure-domain.beta.kubernetes.io/zone
    tolerations:
    - key: key
      operator: Equal
      value: value
      effect: NoSchedule
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  schedulerName: default-scheduler
  shareProcessNamespace: false
  hostNetwork: false
  securityContext:
    runAsUser: 1000
  serviceAccountName: foo
  automountServiceAccountToken: true
  hostAliases:
  - ip: \"127.0.0.1\"
    hostnames:
    - \"foo.local\"
    - \"bar.local\"
  volumes:
  - name: storage
    persistentVolumeClaim:
      claimName: mysql-pv-claim
  - name: config-volume
    configMap:
      name: special-config
      items:
      - key: SPECIAL_LEVEL
        path: keys
  containers:
  - name: xo
    image: registry.io/library/xo
    imagePullPolicy: IfNotPresent
    imagePullSecrets:
    - name: regcred
    env:
    - name: FOO
      value: bar
    - name: SPECIAL_KEY
      valueFrom:
        configMapKeyRef:
          name: special-config
          key: special.how
    command: [\"/bin/sh\"]
    args: [\"-c\", \"while true; do /etc/config/keys; sleep 10;done\"]
    ports:
    - containerPort: 8080
      protocol: TCP
    resources: 
      limits:
        cpu: 100m
        memory: 128M
    volumeMounts:
    - name: storage
      mountPath: /data
      subPath: demo
    - name: config-volume
      mountPath: /etc/config
    lifecycle:
      postStart:
        exec:
          command: [\"/bin/sh\", \"-c\", \"echo Hello\"]
    readinessProbe:
      httpGet:
        path: /
        port: 8080
        initialDelaySeconds: 5
        periodSeconds: 5
        successThreshold: 1
"

  local deploySample="
apiVersion: apps/v1
kind: Deployment
metadata:
  name: xo
  namespace: default
spec:
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 1
  selector:
    matchLabels:
      app: xo
  template:
    metadata:
      labels:
        app: xo
    annotations:
      alpha.istio.io/sidecar: ignore
    spec:
      nodeSelector:
        disk: ssd
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/project
                operator: In
                values:
                - demo
        podAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: security
                operator: In
                values:
                - S1
            topologyKey: failure-domain.beta.kubernetes.io/zone
        tolerations:
        - key: key
          operator: Equal
          value: value
          effect: NoSchedule
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      shareProcessNamespace: false
      hostNetwork: false
      securityContext:
        runAsUser: 1000
      serviceAccountName: foo
      automountServiceAccountToken: true
      hostAliases:
      - ip: \"127.0.0.1\"
        hostnames:
        - \"foo.local\"
        - \"bar.local\"
      volumes:
      - name: storage
        persistentVolumeClaim:
          claimName: test-pv-claim
      - name: config-volume
        configMap:
          name: special-config
          items:
          - key: SPECIAL_LEVEL
            path: keys
      containers:
      - name: xo
        image: registry.io/library/xo
        imagePullPolicy: IfNotPresent
        imagePullSecrets:
        - name: regcred
        env:
        - name: FOO
          value: bar
        - name: SPECIAL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        command: [\"/bin/sh\"]
        args: [\"-c\", \"while true; do cat /etc/config/keys; sleep 10;done\"]
        ports:
        - containerPort: 8080
          protocol: TCP
        resources: 
          limits:
            cpu: 100m
            memory: 128M
        volumeMounts:
        - name: storage
          mountPath: /data
          subPath: demo
        - name: config-volume
          mountPath: /etc/config
        lifecycle:
          postStart:
            exec:
              command: [\"/bin/sh\", \"-c\", \"echo Hello\"]
        readinessProbe:
          httpGet:
            path: /
            port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            successThreshold: 1
"

  local daemonsetSample="
apiVersion: apps/v1
kind: DaemonSet
metadata:
  annotations:
    describe: hello
  labels:
    service_name: demo
  name: demo
  namespace: default
spec:
  selector:
    matchLabels:
      name: demo
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: foo
    spec:
      tolerations:
      - effect: NoSchedule
        operator: Exists
      volumes:
      - name: storage
        nfs:
          server: 127.0.0.1
          path: /nas
      containers:
      - name: demo
        image: registry.io/library/demo
        imagePullPolicy: Always
        env:
        - name: MODE
          value: restart
        resources:
          requests:
            cpu: 256m
            memory: 512Mi
        volumeMounts:
        - mountPath: /data
          name: storage
"

  local statefulsetSample="
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: demo
  name: demo
  namespace: default
spec:
  replicas: 1
  podManagementPolicy: OrderedReady
  selector:
    matchLabels:
      app: demo
  updateStrategy:
    rollingUpdate:
      partition: 0
    type: RollingUpdate
  volumeClaimTemplates:
  - metadata:
      name: mydata
    spec:
      accessModes: [\"ReadWriteOnce\"]
      resources:
        requests:
          storage: 5Gi
  template:
    metadata:
      labels:
        app: demo
    spec:
      initContainers:
      - name: init
        command:
        - /bin/bash
        - -c
        - rm -Rf /data
        image: registry.io/library/busybox
        imagePullPolicy: IfNotPresent
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/data
          name: mydata
      containers:
      - name: demo
        envFrom:
        - secretRef:
            name: my-secret
        image: registry.io/library/demo
        imagePullPolicy: IfNotPresent
        resources: {}
        volumeMounts:
        - mountPath: /var/lib/data
          name: mydata
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
"

  local jobSample="
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    job-name: pi
  name: pi
  namespace: default
spec:
  backoffLimit: 4
  completions: 1
  parallelism: 1
  selector:
    matchLabels:
      app: pi
  template:
    metadata:
      labels:
        app: pi
        job-name: pi
    spec:
      containers:
      - name: pi
        command:
        - perl
        - -Mbignum=bpi
        - -wle
        - print bpi(2000)
        image: perl
        imagePullPolicy: Always
        resources: {}
      dnsPolicy: ClusterFirst
      restartPolicy: Never
      schedulerName: default-scheduler
      securityContext: {}
"

  local cronjobSample="
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: \"*/1 * * * *\"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
"

  local horizontalpodautoscalerSample="
apiVersion: autoscaling/v2beta1
kind: HorizontalPodAutoscaler
metadata:
  name: webserver
  namespace: default
  labels:
    app: webserver-hpa-cpu
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: webserver
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      targetAverageUtilization: 80
"

  local limitrangeSample="
apiVersion: v1  
 kind: LimitRange  
 metadata:  
   name: test-limit-range  
 spec:  
   limits:  
   - type: Container
     default:  
       memory: 512Mi  
     defaultRequest:  
       memory: 256Mi
   - type: PersistentVolumeClaim
     max:
       storage: 2Gi
     min:
       storage: 1Gi
---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: storagequota
spec:
  hard:
    persistentvolumeclaims: "5"
    requests.storage: "5Gi"
"

  local podsecuritypolicySample="
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted-advanced
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'docker/default'
    apparmor.security.beta.kubernetes.io/allowedProfileNames: 'runtime/default'
    seccomp.security.alpha.kubernetes.io/defaultProfileName:  'docker/default'
    apparmor.security.beta.kubernetes.io/defaultProfileName:  'runtime/default'
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  readOnlyRootFilesystem: false
"

  local networkpolicySample="
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
    - namespaceSelector:
        matchLabels:
          project: myproject
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 6379
  egress:
  - to:
    - ipBlock:
        cidr: 10.0.0.0/24
    ports:
    - protocol: TCP
      port: 5978
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
spec:
  podSelector: {}
  policyTypes:
  - Ingress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all-ingress
spec:
  podSelector: {}
  ingress:
  - {}
  policyTypes:
  - Ingress
"

  case $1 in
  "template")
    echo "https://github.com/dennyzhang/kubernetes-yaml-templates"
    ;;
  "online")
    echo "https://k8syaml.com/"
    ;;
  "docker")
    echo "$dockerSample"
    ;;
  "secret")
    echo "$secretSample"
    ;;
  "cm" | "configmap")
    echo "$configmapSample"
    ;;
  "role" | "rb" | "sa" | "rolebinding" | "serviceaccount" | "rbac")
    echo "$rbacSample"
    ;;
  "pv" | "pvc" | "sc" | "storageclass")
    echo "$storageSample"
    ;;
  "svc" | "service")
    echo "$serviceSample"
    ;;
  "ing" | "ingress")
    echo "$ingressSample"
    ;;
  "pod")
    echo "$podSample"
    ;;
  "deploy" | "deployment")
    echo "$deploySample"
    ;;
  "sts" | "statefulset")
    echo "$statefulsetSample"
    ;;
  "ds" | "daemonset")
    echo "$daemonsetSample"
    ;;
  "job")
    echo "$jobSample"
    ;;
  "cj" | "cronjob")
    echo "$cronjobSample"
    ;;
  "hpa" | "horizontalpodautoscaler")
    echo "$horizontalpodautoscalerSample"
    ;;
  "lr" | "limit" | "limitrange" | "quota")
    echo "$limitrangeSample"
    ;;
  "psp" | "podsecuritypolicy")
    echo "$podsecuritypolicySample"
    ;;
  "np" | "networkpolicy")
    echo "$networkpolicySample"
    ;;
  esac
}

trap "exit 1" SIGINT SIGQUIT

main "$@"
